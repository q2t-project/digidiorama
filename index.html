<!doctype html>
<html lang="ja">
<link rel="icon" href="data:,">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="data:,">
  <title>digidiorama viewer/</title>
  <style>
    :root { --bg: #0b1020; --fg: #e6edf3; --accent: #5aa9ff; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui}
    #app{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr}
    header{display:flex;gap:.5rem;align-items:center;padding:.5rem .75rem;background:#0e142a;border-bottom:1px solid #1d2748}
    header h1{font-size:14px;font-weight:600;margin:0;letter-spacing:.3px}
    header .spacer{flex:1}
    header select, header button{
      appearance:none;border:1px solid #2a3969;background:#131a33;color:var(--fg);
      padding:.5rem 1rem;border-radius:.4rem;cursor:pointer;min-height:44px
    }
    header button:hover, header select:hover{border-color:#39529c;background:#1a2347}
    #main{display:grid;grid-template-columns:1fr 250px;overflow:hidden}
    #viewer{position:relative;overflow:hidden}
    #panel{background:#10172c;border-left:1px solid #1d2748;padding:.5rem;overflow-y:auto;transition:transform .3s ease}
    #panel h2{font-size:13px;margin:.5rem 0}
    #panel .meta-item, #panel .error-item, #panel .node-item{font-size:12px;margin-bottom:.25rem}
    .credit{position:absolute;right:.5rem;bottom:.5rem;font-size:11px;opacity:.7}
    canvas{display:block;width:100%;height:100%;}
    /* タブUI（モバイルのみ表示） */
    #tabs { display:none; margin-bottom:.5rem; }
    #tabs button { flex:1; padding:.5rem; border:none; background:#2a3969; color:#fff; border-radius:.3rem; cursor:pointer; }
    #tabs button.active { background:var(--accent); }
    .tab-pane { display:block; }
    /* モバイル時: ドロワー＋タブ */
    @media(max-width:600px){
      #main{grid-template-columns:1fr;}
      #panel{position:absolute;z-index:10;width:100%;height:40%;bottom:0;left:0;border-left:none;border-top:1px solid #1d2748;transform:translateY(100%)}
      #panel.open{transform:translateY(0)}
      #fab{position:absolute;right:.75rem;bottom:.75rem;width:56px;height:56px;border-radius:50%;background:var(--accent);color:#fff;border:none;font-size:24px;cursor:pointer;z-index:20}
      #tabs { display:flex; gap:.5rem; }
      #tab-content .tab-pane { display:none; }
      #tab-content .tab-pane.active { display:block; }
    }
    @media(min-width:601px){
      #panel{width:250px;right:0;top:0;height:100%;transform:translateX(0)}
      #panel.closed{transform:translateX(100%)}
      #fab{position:absolute;right:.75rem;bottom:.75rem;width:56px;height:56px;border-radius:50%;background:var(--accent);color:#fff;border:none;font-size:24px;cursor:pointer;z-index:20}
      #tabs { display:none; }
      #tab-content .tab-pane { display:block; }
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "ajv": "https://esm.sh/ajv@8/dist/2020?bundle"
      }
    }
  </script>
</head>
<body>
  <div id="app">
    <header>
      <h1 data-i18n="title">デジジオラマ</h1>
      <div class="spacer"></div>
      <select id="fileSelect"></select>
      <select id="langSelect">
        <option value="ja">日本語</option>
        <option value="en">English</option>
      </select>
      <button id="btnReset" data-i18n="reset">Reset</button>
      <button id="btnFit">Fit</button>
      <div id="layersMenu" style="position:relative;">
        <button id="btnLayers" data-i18n="layers">Layers ▼</button>
        <div id="layersDropdown" style="display:none;position:absolute;right:0;top:100%;background:#131a33;border:1px solid #2a3969;padding:.5rem;border-radius:.4rem;">
          <label><input type="checkbox" id="toggle-nodes" checked /> Nodes</label><br/>
          <label><input type="checkbox" id="toggle-edges" checked /> Edges</label><br/>
          <label><input type="checkbox" id="toggle-labels" checked /> Labels</label><br/>
          <label><input type="checkbox" id="toggle-aux" checked /> Auxiliary</label>
        </div>
      </div>
    </header>
    <div id="main">
      <div id="viewer"></div>
      <div id="panel" class="closed">
        <div id="tabs">
          <button data-tab="node" class="active">Node</button>
          <button data-tab="errors">Errors</button>
          <button data-tab="meta">Meta</button>
        </div>
        <div id="tab-content">
          <div id="node" class="tab-pane active"></div>
          <div id="errors" class="tab-pane"></div>
          <div id="meta" class="tab-pane"></div>
        </div>
      </div>
    </div>
    <button id="fab">≡</button>
  </div>
  <div class="credit">MIT © q2t-project / Content © respective authors</div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import Ajv from 'ajv';

    const container=document.getElementById('viewer');
    const scene=new THREE.Scene();scene.background=new THREE.Color(0x0b1020);

    const camera=new THREE.PerspectiveCamera(60,1,0.1,1000);
    camera.up.set(0,0,1);
    const renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    container.appendChild(renderer.domElement);

    const controls=new OrbitControls(camera,renderer.domElement);
    controls.enableDamping=true;
    controls.zoomSpeed = window.innerWidth<600 ? 1.2 : 2;
    controls.rotateSpeed = window.innerWidth<600 ? 0.8 : 1.0;
    controls.panSpeed = window.innerWidth<600 ? 0.5 : 1.0;
    controls.minDistance = 1;
    controls.maxDistance = 200;
    controls.update();

    scene.add(new THREE.AmbientLight(0xffffff,0.6));
    const dir=new THREE.DirectionalLight(0xffffff,0.8);dir.position.set(5,10,7);scene.add(dir);

    const nodeGroup=new THREE.Group();
    const edgeGroup=new THREE.Group();
    const labelGroup=new THREE.Group();
    const auxiliaryGroup=new THREE.Group();
    scene.add(edgeGroup,nodeGroup,labelGroup,auxiliaryGroup);

    function makeLabelPlane(text, options = {}, nodeId=null) {
      const fontSize  = options.fontSize  ?? 32;
      const fontFamily= options.fontFamily?? "Arial";
      const color     = options.color     ?? "white";
      const opacity   = options.opacity   ?? 1.0;
      const background= options.background?? null;
      const plane     = options.plane     ?? "zx";
      const direction = options.direction ?? 0;
      const worldScale = options.worldScale ?? 0.1;

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = `${fontSize}px ${fontFamily}`;
      const metrics = ctx.measureText(text);
      canvas.width  = metrics.width + 20;
      canvas.height = fontSize * 1.5;
      ctx.font = `${fontSize}px ${fontFamily}`;
      if (background) { ctx.fillStyle = background; ctx.fillRect(0,0,canvas.width,canvas.height); }
      ctx.fillStyle = color;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity, side: THREE.DoubleSide });
      const geom = new THREE.PlaneGeometry(canvas.width * worldScale, canvas.height * worldScale);
      const mesh = new THREE.Mesh(geom, mat);

      switch (plane) {
        case "yz":
          mesh.rotation.y = Math.PI/2;
          mesh.rotation.z = Math.PI/2;
          break;
        case "zx":
          mesh.rotation.x = Math.PI/2;
          mesh.rotation.y += Math.PI;
          break;
      }
      if (direction) mesh.rotation.z += THREE.MathUtils.degToRad(direction);

      mesh.position.set(...(options.offset ?? [0,0,0]));
      if(nodeId) mesh.userData.nodeId = nodeId;
      return mesh;
    }

    const nodeById=new Map();

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    renderer.domElement.addEventListener('click',event=>{
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse,camera);
      const intersects = raycaster.intersectObjects(nodeGroup.children.concat(labelGroup.children),true);
      if(intersects.length>0){
        const mesh = intersects[0].object;
        if(mesh.userData.nodeId){
          const node=nodeById.get(mesh.userData.nodeId).userData;
          showNode(node);
        }
      }
    });

    function fitCameraToScene(padding=1.2){
      controls.reset();  // ★追加：毎回リセット

      const box = new THREE.Box3().setFromObject(scene);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
      cameraZ *= padding;
      camera.position.set(center.x + cameraZ, center.y + cameraZ, center.z + cameraZ);
      controls.target.copy(center);
      controls.update();
    }

    function buildScene(data){
      nodeGroup.clear();edgeGroup.clear();labelGroup.clear();auxiliaryGroup.clear();nodeById.clear();
      const sphereGeom=new THREE.SphereGeometry(0.05,8,8);

      for(const n of data.nodes||[]){
        const mat=new THREE.MeshBasicMaterial({color:0xaaaaaa,transparent:true,opacity:0.3});
        const m=new THREE.Mesh(sphereGeom,mat);m.position.set(...n.position);m.userData=n;
        nodeGroup.add(m);nodeById.set(n.id,m);
        if(n.label){
          const labelMesh=makeLabelPlane(n.label,n.labelAttr||{},n.id);
          m.add(labelMesh);
        }
      }

      for(const e of data.edges||[]){
        const a=nodeById.get(e.source),b=nodeById.get(e.target);if(!a||!b)continue;
        const geo=new THREE.BufferGeometry().setFromPoints([a.position,b.position]);
        const mat=new THREE.LineBasicMaterial({color:e.color||0x9ec1ff,transparent:true,opacity:e.opacity||1.0});
        edgeGroup.add(new THREE.Line(geo,mat));
        if(e.label){
          const midpoint=new THREE.Vector3().addVectors(a.position,b.position).multiplyScalar(0.5);
          const edgeLabel=makeLabelPlane(e.label,e.labelAttr||{});edgeLabel.position.copy(midpoint);
          labelGroup.add(edgeLabel);
        }
      }

      for(const aux of data.auxiliary||[]){
        if(aux.type === "grid" && aux.grid){
          const g = aux.grid;
          if(g.shape === "rect"){
            const size = g.size ?? 10;
            const divisions = g.divisions ?? 10;
            const color = g.color ?? 0x444444;
            const grid = new THREE.GridHelper(size, divisions, color, color);
            grid.material.opacity = g.opacity ?? 0.3;
            grid.material.transparent = true;
            if(g.plane==="yz"){grid.rotation.z=Math.PI/2;}
            if(g.plane==="zx"){grid.rotation.x=Math.PI/2;}
            if(g.position){grid.position.set(...g.position);}
            if(aux.visible===false) grid.visible=false;
            auxiliaryGroup.add(grid);
          }
          if(g.shape === "polar"){
            const rings = g.rings ?? 5;
            const segments = g.segments ?? 36;
            const radius = g.size ?? 5;
            const mat = new THREE.LineBasicMaterial({color:g.color??0x444444, transparent:true, opacity:g.opacity??0.3});
            for(let r=1;r<=rings;r++){
              const geom = new THREE.BufferGeometry();
              const pts=[];
              for(let i=0;i<=segments;i++){
                const theta = (i/segments)*2*Math.PI;
                pts.push(new THREE.Vector3(Math.cos(theta)*radius*r/rings, Math.sin(theta)*radius*r/rings, 0));
              }
              geom.setFromPoints(pts);
              const circle=new THREE.LineLoop(geom,mat);
              if(g.plane==="yz"){circle.rotation.y=Math.PI/2;}
              if(g.plane==="zx"){circle.rotation.x=Math.PI/2;}
              if(g.position){circle.position.set(...g.position);}
              if(aux.visible===false) circle.visible=false;
              auxiliaryGroup.add(circle);
            }
          }
        }
        if(aux.type === "axis"){
          const len = aux.length ?? 1;
          const colors = aux.colors || ["#ff0000","#00ff00","#0000ff"];
          const axes = [
            { dir: new THREE.Vector3(1,0,0), color: colors[0] },
            { dir: new THREE.Vector3(0,1,0), color: colors[1] },
            { dir: new THREE.Vector3(0,0,1), color: colors[2] }
          ];
          axes.forEach(axisDef=>{
            const geom = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(0,0,0),
              axisDef.dir.clone().multiplyScalar(len)
            ]);
            const mat = new THREE.LineBasicMaterial({ color: axisDef.color });
            const line = new THREE.Line(geom,mat);
            if(aux.position){line.position.set(...aux.position);}
            if(aux.visible===false) line.visible=false;
            auxiliaryGroup.add(line);
          });
        }
      }

      showMeta(data.meta,data);
      fitCameraToScene();
    }

function showMeta(meta, data) {
  const box = document.getElementById('meta');
  box.replaceChildren(); // 毎回きれいにする

  // メタ項目
  if (meta) {
    for (const [k, v] of Object.entries(meta)) {
      const d = document.createElement('div');
      d.className = 'meta-item';
      d.textContent = `${k}: ${v}`;
      box.appendChild(d);
    }
  }

  // counts を毎回生成して追加（idは不要）
  const counts = document.createElement('div');
  counts.className = 'meta-item';
  counts.innerHTML =
    `<p>Nodes: ${(data.nodes || []).length}</p>` +
    `<p>Edges: ${(data.edges || []).length}</p>`;
  box.appendChild(counts);
}


    function showNode(node){
      const box=document.getElementById('node');box.innerHTML='';
      if(!node)return;
      for(const [k,v] of Object.entries(node)){
        const d=document.createElement('div');d.className='node-item';d.textContent=`${k}: ${v}`;box.appendChild(d);
      }
    }

    function showErrors(errs){const box=document.getElementById('errors');box.innerHTML='';
      (errs||[]).forEach(e=>{const d=document.createElement('div');d.className='error-item';d.textContent=e;box.appendChild(d);});}

  let dict = {};
  async function loadLocale(locale='ja'){
    const url = `./assets/i18n/${locale}.json?v=${Date.now()}`;
    try{
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      dict = await res.json();
    }catch(e){
      console.warn(`i18n ${locale} not found at ${url} — fallback to defaults.`, e);
      dict = {};
    }
    applyI18n();
  }

      function t(key){return dict[key]||key;}
      function applyI18n(){
    document.querySelectorAll('[data-i18n]').forEach(el=>{
      const k = el.dataset.i18n;
      if (k in dict) el.textContent = dict[k];
    });
  }
    document.querySelectorAll('#tabs button').forEach(btn=>{
      btn.onclick=()=>{
        const tab=btn.dataset.tab;
        document.querySelectorAll('#tab-content .tab-pane').forEach(p=>{
          p.classList.toggle('active',p.id===tab);
        });
        document.querySelectorAll('#tabs button').forEach(b=>b.classList.toggle('active',b===btn));
      };
    });
    if(window.innerWidth<=600){
      document.querySelector('#node').classList.add('active');
    }

    const panel=document.getElementById('panel');
    const fab=document.getElementById('fab');
    fab.onclick=()=>{panel.classList.toggle('open');panel.classList.toggle('closed');};

    let touchStartX=0,touchStartY=0;
    window.addEventListener("touchstart",e=>{
      if(!e.touches || e.touches.length===0) return;
      touchStartX=e.touches[0].clientX;
      touchStartY=e.touches[0].clientY;
    }, {passive:true});
    window.addEventListener("touchend",e=>{
      if(!e.changedTouches || e.changedTouches.length===0) return;
      const dx=e.changedTouches[0].clientX-touchStartX;
      const dy=e.changedTouches[0].clientY-touchStartY;
      if(Math.abs(dx)>50 && window.innerWidth>600){
        if(dx<0) panel.classList.add('open'); else panel.classList.remove('open');
      }
      if(Math.abs(dy)>50 && window.innerWidth<=600){
        if(dy<0) panel.classList.add('open'); else panel.classList.remove('open');
      }
    }, {passive:true});

    document.getElementById('btnReset').onclick=()=>{fitCameraToScene();};
    document.getElementById('langSelect').onchange=(ev)=>{loadLocale(ev.target.value)};
    document.getElementById('btnLayers').onclick=()=>{const dd=document.getElementById('layersDropdown');dd.style.display=dd.style.display==='none'?'block':'none';};
    document.getElementById('toggle-nodes').onchange=(ev)=>{nodeGroup.visible=ev.target.checked;};
    document.getElementById('toggle-edges').onchange=(ev)=>{edgeGroup.visible=ev.target.checked;};
    document.getElementById('toggle-labels').onchange=(ev)=>{labelGroup.visible=ev.target.checked;};
    document.getElementById('toggle-aux').onchange=(ev)=>{auxiliaryGroup.visible=ev.target.checked;};

    const ajv = new Ajv({ allErrors: true, strict: false, validateSchema: false });
let validateModel = null;
let validateManifest = null;

async function loadSchemas(){
  try {
    const [modelSchema, manifestSchema] = await Promise.all([
      fetch('./digidiorama_schema_v2.json', { cache: 'no-store' })
        .then(r => r.ok ? r.json() : Promise.reject(new Error('model schema not found'))),
      fetch('./manifest_schema_v2.json', { cache: 'no-store' })
        .then(r => r.ok ? r.json() : Promise.reject(new Error('manifest schema not found')))
    ]);
    validateModel = ajv.compile(modelSchema);
    validateManifest = ajv.compile(manifestSchema);
  } catch (err) {
    console.warn('Schema load failed, fallback to minimal schema', err);
    const fallback = {
      type: 'object',
      properties: {
        meta: { type: 'object' },
        nodes: { type: 'array' },
        edges: { type: 'array' },
        auxiliary: { type: 'array' }
      },
      required: ['meta','nodes','edges']
    };
    validateModel = ajv.compile(fallback);
  }
}

// --- Fit（シーン全体にビューを合わせる） ---
function fitCameraToScene(padding = 1.2) {
  // 一旦慣性などをリセット（既存の OrbitControls を想定）
  if (typeof controls?.reset === 'function') controls.reset();

  // 何も無い時のフェイルセーフ
  const box = new THREE.Box3().setFromObject(scene);
  if (!isFinite(box.min.x) || !isFinite(box.max.x)) {
    // 何もない場合は原点付近を見る
    camera.position.set(3, 3, 3);
    if (controls) controls.target.set(0, 0, 0);
    if (controls) controls.update();
    return;
  }

  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);

  // 視野角から必要距離を計算
  const fov = camera.fov * (Math.PI / 180);
  let dist = Math.abs(maxDim / 2 / Math.tan(fov / 2));
  dist *= padding;

  // 斜め上から見下ろす位置に配置（軸はあなたの既存設定に合わせて下さい）
  camera.position.set(center.x + dist, center.y + dist, center.z + dist);

  if (controls) {
    controls.target.copy(center);
    controls.update();
  }
}

    function extraChecks(data){
  const msgs=[];
  const ids=new Set();
  for(const n of (data.nodes||[])){
    if(!n || typeof n.id!=='string') continue;
    if(ids.has(n.id)) msgs.push(`Duplicate node id: ${n.id}`);
    ids.add(n.id);
  }
  for(const e of (data.edges||[])){
    if(e && typeof e.source==='string' && !ids.has(e.source)) msgs.push(`Edge source not found: ${e.source}`);
    if(e && typeof e.target==='string' && !ids.has(e.target)) msgs.push(`Edge target not found: ${e.target}`);
  }
  return msgs;
}
function runValidation(data){
  const msgs = [];
  // validateModel を使う版（外部スキーマ対応）
  if (typeof validateModel === 'function') {
    const ok = validateModel(data);
    if (!ok) {
      msgs.push(...validateModel.errors.map(e => `${e.instancePath || '/'} ${e.message}`));
    }
  }
  // 旧版との後方互換（validate がある環境）
  else if (typeof validate === 'function') {
    const ok = validate(data);
    if (!ok) {
      msgs.push(...validate.errors.map(e => `${e.instancePath || '/'} ${e.message}`));
    }
  }
  // 追加の整合チェック（ID重複/参照不整合）
  msgs.push(...extraChecks(data));
  showErrors(msgs);
}

async function loadManifest(){const res=await fetch('./assets/manifest.json');return res.json();}
    async function loadDigidiorama(path){const res=await fetch(path);return res.json();}

    const select=document.getElementById('fileSelect');
    loadSchemas().then(()=> loadManifest()).then(list=>{
      select.innerHTML = "";
      let firstPath = null;

      if(Array.isArray(list)){ 
        list.forEach((item,idx)=>{
          const opt=document.createElement('option');
          opt.value=item.path;
          opt.textContent=item.title||item.path;
          select.appendChild(opt);
          if(idx===0) firstPath=item.path;
        });
      } else if(list.groups){
        list.groups.forEach(group=>{
          const optgroup=document.createElement('optgroup');
          optgroup.label=group.title;
          (group.files||[]).forEach(item=>{
            const opt=document.createElement('option');
            opt.value=item.path;
            opt.textContent=item.title||item.path;
            optgroup.appendChild(opt);
            if(!firstPath) firstPath=item.path;
          });
          select.appendChild(optgroup);
        });
      }

      if(firstPath){
        select.value=firstPath;
        loadDigidiorama(firstPath).then(data=>{runValidation(data);buildScene(data);});
      }
    });

    select.onchange=()=>{loadDigidiorama(select.value).then(data=>{runValidation(data);buildScene(data);});};
    document.getElementById('btnFit').addEventListener('click', () => fitCameraToScene());

    loadLocale('ja');

    const ro=new ResizeObserver(()=>{
      const {clientWidth:w,clientHeight:h}=container;
      renderer.setSize(w,h,true);
      camera.aspect=w/h;
      camera.updateProjectionMatrix();
    });
    ro.observe(container);

    function animate(){controls.update();renderer.render(scene,camera);requestAnimationFrame(animate);}animate();
  </script>
</body>
</html>
