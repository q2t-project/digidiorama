<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>digidiorama viewer/</title>
    <base href="/digidiorama/">
    <link rel="icon" href="data:,">
    <style>
      :root { --bg: #0b1020; --fg: #e6edf3; --accent: #5aa9ff; }
      html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font:14px/1.4 system-ui }
      #app { position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr }
      header { display:flex; gap:.5rem; align-items:center; padding:.5rem .75rem; background:#0e142a; border-bottom:1px solid #1d2748 }
      header h1 { font-size:14px; font-weight:600; margin:0; letter-spacing:.3px }
      header .spacer { flex:1 }

      header button {appearance:none; border:1px solid #2a3969; background:#101a3a; color:#fff; padding:.4rem .7rem; border-radius:.4rem; cursor:pointer; min-height:36px; font-size:0.9rem;}
      header button:hover {border-color:#39529c;background:#1a2347;}

      #main { display:grid; grid-template-columns:1fr 250px; overflow:hidden }
      #viewer { position:relative; overflow:hidden }
      #panel { background:#10172c; border-left:1px solid #1d2748; position:relative; padding:.5rem; overflow-y:auto; transition:transform .3s ease }
      #panel h2 { font-size:13px; margin:.5rem 0 }
      #panel .meta-item, #panel .error-item, #panel .node-item { font-size:12px; margin-bottom:.25rem }
      .credit { position:absolute; right:.5rem; bottom:.5rem; font-size:11px; opacity:.7 }
      canvas { display:block; width:100%; height:100%; }
      #tabs { display:none; margin-bottom:.5rem; }
      #tabs button {
        flex:1; padding:.5rem; border:none; background:#2a3969; color:#fff; border-radius:.3rem; cursor:pointer;
      }
      #tabs button.active { background:#39529c; }
      #tab-content { font-size:13px; }
      .tab-pane { display:block; }
      @media(max-width:600px){
      header button {
        font-size:0.8rem;
        padding:0.3rem 0.6rem;
        min-height:32px;
      }
        #main { grid-template-columns:1fr; }
        #panel {
          position:absolute; z-index:10; width:100%; height:40%; bottom:0; left:0;
          border-left:none; border-top:1px solid #1d2748; transform:translateY(100%)
        }
        #panel.open { transform:translateY(0) }
        #fab {
          position:absolute; right:.75rem; bottom:.75rem; width:56px; height:56px; border-radius:50%;
          background:var(--accent); color:#fff; border:none; font-size:24px; cursor:pointer; z-index:20
        }
        #tabs { display:flex; gap:.5rem; }
        #tab-content .tab-pane { display:none; }
        #tab-content .tab-pane.active { display:block; }
      }
      @media(min-width:601px){
        #panel { width:250px; right:0; top:0; height:100%; transform:translateX(0) }
        #panel.closed { transform:translateX(100%) }
        #fab {
          position:absolute; right:.75rem; bottom:.75rem; width:56px; height:56px; border-radius:50%;
          background:var(--accent); color:#fff; border:none; font-size:24px; cursor:pointer; z-index:20
        }
        #tabs { display:none; }
        #tab-content .tab-pane { display:block; }
      }

      #layersDropdown { position:absolute; top:120%; right:0; background:#0e142a; border:1px solid #1d2748; padding:.5rem; border-radius:.4rem; min-width:240px; display:none; }
      #layersDropdown label { display:block; font-size:12px; margin:.3rem 0 }

      .node-item { padding:.25rem .35rem; border-radius:.25rem; background:#111c3b; margin-bottom:.25rem; }
      .error-item { padding:.25rem .35rem; border-radius:.25rem; background:#3b1111; margin-bottom:.25rem; }
      .meta-item {  padding:.25rem .35rem; border-radius:.25rem; background:#112b3b; margin-bottom:.25rem; }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
          "ajv": "https://esm.sh/ajv@8/dist/2020?bundle"
        }
      }
    </script>
  </head>
  <body>
    <div id="app">
      <header>
        <svg xmlns="http://www.w3.org/2000/svg" width="46.892pt" height="9.166pt" viewBox="0 0 46.892 9.166">
        <path d="M4.641,1.050 L4.641,0.074 L0.714,0.074 Q0.568,0.074 0.463,0.179 Q0.358,0.284 0.358,0.441 L0.358,0.683 Q0.358,0.829 0.463,0.940 Q0.568,1.050 0.714,1.050 L4.641,1.050 Z M0.525,8.789 Q0.525,8.935 0.630,9.045 Q0.735,9.156 0.883,9.156 L2.940,9.156 Q3.307,9.156 3.570,8.894 L3.780,8.684 Q4.043,8.421 4.043,8.054 L4.043,4.379 Q4.043,4.210 4.143,4.111 Q4.243,4.011 4.410,4.011 L6.500,4.011 Q6.658,4.011 6.768,3.901 Q6.878,3.790 6.878,3.644 L6.878,3.401 Q6.878,3.244 6.768,3.139 Q6.658,3.034 6.500,3.034 L0.358,3.034 Q0.210,3.034 0.105,3.139 Q0.000,3.244 0.000,3.401 L0.000,3.644 Q0.000,3.790 0.105,3.901 Q0.210,4.011 0.358,4.011 L2.709,4.011 Q2.878,4.011 2.976,4.111 Q3.076,4.210 3.076,4.379 L3.076,7.801 Q3.076,7.959 2.966,8.069 Q2.856,8.179 2.699,8.179 L0.883,8.179 Q0.735,8.179 0.630,8.284 Q0.525,8.389 0.525,8.546 L0.525,8.789 Z M6.290,1.365 Q6.448,1.365 6.541,1.271 Q6.636,1.176 6.636,1.019 L6.636,0.399 Q6.636,0.241 6.541,0.148 Q6.448,0.053 6.290,0.053 Q5.954,0.053 5.954,0.399 L5.954,1.019 Q5.954,1.365 6.290,1.365 Z M5.271,1.365 Q5.608,1.365 5.608,1.019 L5.608,0.399 Q5.608,0.053 5.271,0.053 Q5.114,0.053 5.019,0.148 Q4.925,0.241 4.925,0.399 L4.925,1.019 Q4.925,1.176 5.019,1.271 Q5.114,1.365 5.271,1.365 Z M14.006,1.365 Q14.164,1.365 14.259,1.271 Q14.354,1.176 14.354,1.019 L14.354,0.399 Q14.354,0.241 14.259,0.148 Q14.164,0.053 14.006,0.053 Q13.672,0.053 13.672,0.399 L13.672,1.019 Q13.672,1.365 14.006,1.365 Z M12.989,1.365 Q13.324,1.365 13.324,1.019 L13.324,0.399 Q13.324,0.053 12.989,0.053 Q12.832,0.053 12.736,0.148 Q12.641,0.241 12.641,0.399 L12.641,1.019 Q12.641,1.176 12.736,1.271 Q12.832,1.365 12.989,1.365 Z M10.111,2.016 Q10.364,2.289 10.720,2.289 L11.644,2.289 Q11.813,2.289 11.911,2.189 Q12.011,2.089 12.011,1.921 L12.011,1.690 Q12.011,1.523 11.911,1.422 Q11.813,1.322 11.644,1.322 L11.152,1.322 Q10.794,1.322 10.541,1.050 L9.859,0.272 Q9.608,0.000 9.250,0.000 L8.704,0.000 Q8.494,0.000 8.494,0.115 Q8.494,0.158 8.579,0.272 L10.111,2.016 Z M9.419,4.630 Q9.670,4.904 10.038,4.904 L10.961,4.904 Q11.130,4.904 11.229,4.804 Q11.329,4.704 11.329,4.536 L11.329,4.305 Q11.329,4.136 11.229,4.038 Q11.130,3.938 10.961,3.938 L10.448,3.938 Q10.080,3.938 9.828,3.664 L9.040,2.783 Q8.789,2.509 8.422,2.509 L7.875,2.509 Q7.675,2.509 7.675,2.614 Q7.675,2.699 7.759,2.783 L9.419,4.630 Z M8.231,9.156 L11.371,9.156 Q11.791,9.156 12.064,8.946 L12.400,8.672 Q12.694,8.441 12.832,8.116 L14.238,4.064 Q14.280,3.947 14.280,3.926 Q14.280,3.706 13.996,3.706 L13.713,3.706 Q13.366,3.706 13.209,4.052 L11.865,7.832 Q11.739,8.190 11.362,8.179 L8.231,8.179 Q8.085,8.179 7.974,8.284 Q7.864,8.389 7.864,8.546 L7.864,8.789 Q7.864,8.935 7.974,9.045 Q8.085,9.156 8.231,9.156 Z M23.540,1.365 Q23.698,1.365 23.793,1.271 Q23.888,1.176 23.888,1.019 L23.888,0.399 Q23.888,0.241 23.793,0.148 Q23.698,0.053 23.540,0.053 Q23.206,0.053 23.206,0.399 L23.206,1.019 Q23.206,1.365 23.540,1.365 Z M22.523,1.365 Q22.858,1.365 22.858,1.019 L22.858,0.399 Q22.858,0.053 22.523,0.053 Q22.366,0.053 22.270,0.148 Q22.175,0.241 22.175,0.399 L22.175,1.019 Q22.175,1.176 22.270,1.271 Q22.366,1.365 22.523,1.365 Z M19.645,2.016 Q19.898,2.289 20.254,2.289 L21.178,2.289 Q21.347,2.289 21.445,2.189 Q21.545,2.089 21.545,1.921 L21.545,1.690 Q21.545,1.523 21.445,1.422 Q21.347,1.322 21.178,1.322 L20.686,1.322 Q20.328,1.322 20.075,1.050 L19.393,0.272 Q19.142,0.000 18.784,0.000 L18.238,0.000 Q18.028,0.000 18.028,0.115 Q18.028,0.158 18.113,0.272 L19.645,2.016 Z M18.953,4.630 Q19.204,4.904 19.572,4.904 L20.495,4.904 Q20.664,4.904 20.763,4.804 Q20.863,4.704 20.863,4.536 L20.863,4.305 Q20.863,4.136 20.763,4.038 Q20.664,3.938 20.495,3.938 L19.982,3.938 Q19.614,3.938 19.362,3.664 L18.574,2.783 Q18.323,2.509 17.956,2.509 L17.409,2.509 Q17.209,2.509 17.209,2.614 Q17.209,2.699 17.293,2.783 L18.953,4.630 Z M17.765,9.156 L20.905,9.156 Q21.325,9.156 21.598,8.946 L21.934,8.672 Q22.228,8.441 22.366,8.116 L23.772,4.064 Q23.814,3.947 23.814,3.926 Q23.814,3.706 23.530,3.706 L23.247,3.706 Q22.900,3.706 22.743,4.052 L21.399,7.832 Q21.273,8.190 20.896,8.179 L17.765,8.179 Q17.619,8.179 17.508,8.284 Q17.398,8.389 17.398,8.546 L17.398,8.789 Q17.398,8.935 17.508,9.045 Q17.619,9.156 17.765,9.156 Z M27.404,2.604 L26.113,7.832 Q26.082,7.980 25.946,8.085 Q25.810,8.190 25.652,8.190 L25.337,8.190 Q25.189,8.190 25.084,8.295 Q24.979,8.400 24.979,8.558 L24.979,8.789 Q24.979,8.935 25.084,9.045 Q25.189,9.156 25.337,9.156 L26.428,9.156 Q26.743,9.156 26.879,8.799 L28.371,2.699 Q28.444,2.404 28.759,2.404 L29.284,2.404 Q29.432,2.404 29.542,2.509 Q29.652,2.614 29.652,2.761 L29.652,7.823 Q29.652,7.980 29.542,8.085 Q29.432,8.190 29.284,8.190 L28.361,8.190 Q28.203,8.190 28.092,8.295 Q27.982,8.400 27.982,8.558 L27.982,8.789 Q27.982,8.935 28.097,9.045 Q28.213,9.156 28.361,9.156 L29.494,9.156 Q29.673,9.156 29.888,9.056 Q30.103,8.956 30.239,8.777 L30.356,8.663 Q30.640,8.379 30.618,8.033 L30.618,2.761 Q30.618,2.614 30.723,2.509 Q30.828,2.404 31.007,2.404 L31.206,2.404 Q31.342,2.404 31.452,2.294 Q31.563,2.184 31.563,2.036 L31.563,1.795 Q31.563,1.637 31.452,1.523 Q31.342,1.406 31.206,1.406 L31.007,1.406 Q30.618,1.406 30.618,1.050 L30.618,0.368 Q30.618,0.220 30.507,0.115 Q30.397,0.010 30.251,0.010 L30.019,0.010 Q29.872,0.010 29.762,0.115 Q29.652,0.220 29.652,0.368 L29.652,1.050 Q29.652,1.208 29.542,1.308 Q29.432,1.406 29.284,1.406 L25.337,1.406 Q25.189,1.406 25.084,1.523 Q24.979,1.637 24.979,1.795 L24.979,2.036 Q24.979,2.184 25.084,2.294 Q25.189,2.404 25.337,2.404 L27.142,2.404 Q27.404,2.404 27.404,2.604 Z M33.841,8.789 Q33.841,8.935 33.946,9.045 Q34.051,9.156 34.198,9.156 L35.647,9.156 Q35.816,9.156 35.983,9.114 Q36.151,9.071 36.330,8.956 L36.592,8.789 Q36.907,8.579 37.065,8.252 L39.102,3.854 Q39.176,3.696 39.217,3.508 Q39.260,3.317 39.260,3.014 Q39.260,2.845 39.165,2.746 Q39.071,2.646 38.892,2.646 L33.034,2.646 Q32.865,2.646 32.765,2.741 Q32.666,2.835 32.666,3.014 L32.666,3.255 Q32.666,3.422 32.760,3.522 Q32.855,3.623 33.034,3.623 L37.768,3.623 Q38.010,3.623 38.010,3.801 Q38.010,3.833 38.005,3.870 Q38.000,3.906 37.978,3.959 L36.162,7.844 Q36.079,8.021 35.941,8.100 Q35.805,8.179 35.637,8.179 L34.198,8.179 Q34.051,8.179 33.946,8.284 Q33.841,8.389 33.841,8.546 L33.841,8.789 Z M33.358,1.050 L38.577,1.050 Q38.735,1.050 38.845,0.940 Q38.955,0.829 38.955,0.683 L38.955,0.441 Q38.955,0.284 38.845,0.179 Q38.735,0.074 38.577,0.074 L33.358,0.074 Q33.211,0.074 33.106,0.179 Q33.001,0.284 33.001,0.441 L33.001,0.683 Q33.001,0.829 33.106,0.940 Q33.211,1.050 33.358,1.050 Z M44.384,8.820 Q44.594,9.166 44.940,9.166 L45.601,9.166 Q45.780,9.166 45.874,9.061 Q45.969,8.956 45.969,8.789 L45.969,8.536 Q45.969,8.159 45.601,8.159 L45.422,8.159 Q45.129,8.159 44.919,7.823 L44.425,6.983 Q44.320,6.814 44.320,6.604 Q44.320,6.426 44.415,6.257 L46.715,2.258 Q46.820,2.079 46.856,1.900 Q46.892,1.721 46.892,1.544 L46.892,0.546 Q46.892,0.167 46.525,0.167 L40.604,0.167 Q40.425,0.167 40.330,0.272 Q40.236,0.377 40.236,0.546 L40.236,0.809 Q40.236,1.186 40.604,1.186 L45.591,1.186 Q45.906,1.186 45.906,1.427 Q45.906,1.628 45.727,1.964 L43.785,5.355 Q43.680,5.522 43.618,5.522 Q43.544,5.522 43.449,5.365 L42.167,3.244 Q41.947,2.888 41.611,2.888 L41.181,2.888 Q40.993,2.888 40.897,2.997 Q40.802,3.107 40.802,3.276 L40.802,3.559 Q40.802,3.906 41.160,3.906 Q41.432,3.906 41.632,4.221 L44.384,8.820 Z" fill="#8080e0" stroke="#0000ff" stroke-width="0.2"/>
        </svg>

        <div class="spacer"></div>
        <button id="btnLoad">File読込</button>
        <button id="btnUrlLoad">URL読込</button>
        <button id="btnReset" data-i18n="reset">再描画</button>
        <div id="layersMenu" style="position:relative;">
          <button id="btnLayers">レイヤ▼</button>
          <div id="layersDropdown"
            style="display:none">
            <label><input type="checkbox" id="toggle-nodes" checked /> Nodes</label>
            <label><input type="checkbox" id="toggle-edges" checked /> Edges</label>
            <label><input type="checkbox" id="toggle-labels" checked /> Labels</label>
            <label><input type="checkbox" id="toggle-aux" checked /> Auxiliary</label>
          </div>
        </div>
      </header>
      <div id="main">
        <div id="viewer"></div>
        <div id="panel" class="closed">
          <div id="tabs">
            <button data-tab="node" class="active">Node</button>
            <button data-tab="errors">Errors</button>
            <button data-tab="meta">Meta</button>
          </div>
          <div id="tab-content">
            <div id="node" class="tab-pane"></div>
            <div id="errors" class="tab-pane"></div>
            <div id="meta" class="tab-pane"></div>
          </div>
          <div class="credit">© q2t-project</div>
        </div>
        <button id="fab">≡</button>
      </div>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import Ajv from "ajv";

      const container = document.getElementById('viewer');
      const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0b1020);

      const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
      camera.up.set(0, 0, 1);
      const renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.zoomSpeed = window.innerWidth < 600 ? 1.2 : 2;
      controls.rotateSpeed = window.innerWidth < 600 ? 0.8 : 1.0;

      // ---- Initial view snapshot & reset helpers (additive) ----
      let initialView = null;
      function snapshotInitialView() {
        initialView = {
          position: camera.position.clone(),
          target: controls.target.clone(),
        };
      }
      function resetView() {
        if (initialView) {
          camera.position.copy(initialView.position);
          controls.target.copy(initialView.target);
          controls.update();
        } else {
          fitCameraToScene();
        }
      }
      // ----------------------------------------------------------

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      const edgeGroup = new THREE.Group();
      const nodeGroup = new THREE.Group();
      const labelGroup = new THREE.Group();
      const auxiliaryGroup = new THREE.Group();
      scene.add(edgeGroup, nodeGroup, labelGroup, auxiliaryGroup);

      function makeLabelPlane(text, options = {}, nodeId = null) {
        const fontSize   = options.fontSize   ?? 32;
        const fontFamily = options.fontFamily ?? "Arial";
        const color      = options.color      ?? "white";
        const opacity    = options.opacity    ?? 1.0;
        const background = options.background ?? null;
        const plane      = options.plane      ?? "zx";
        const direction  = options.direction  ?? 0;
        const worldScale = options.worldScale ?? 0.1;

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.font = `${fontSize}px ${fontFamily}`;
        const textWidth = Math.ceil(ctx.measureText(text).width);
        const textHeight = Math.ceil(fontSize * 1.2);

        canvas.width = textWidth + 8;
        canvas.height = textHeight + 8;

        ctx.font = `${fontSize}px ${fontFamily}`;
        ctx.textBaseline = 'top';
        if (background) {
          ctx.globalAlpha = Math.min(1, Math.max(0, background.opacity ?? 0.5));
          ctx.fillStyle = background.color ?? 'rgba(0,0,0,0.5)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.globalAlpha = 1.0;
        }
        ctx.fillStyle = color;
        ctx.fillText(text, 4, 4);

        const texture = new THREE.CanvasTexture(canvas);
        texture.encoding = THREE.sRGBEncoding;
        const material = new THREE.SpriteMaterial({ map:texture, transparent:true, opacity });

        const sprite = new THREE.Sprite(material);
        sprite.scale.set(canvas.width * worldScale, canvas.height * worldScale, 1);

        // plane/orientation
        const p = plane.toLowerCase();
        sprite.userData.nodeId = nodeId;
        const obj = new THREE.Object3D();
        obj.add(sprite);

        // direction rotation in plane
        const rot = (direction || 0) * (Math.PI / 180);
        if (p === 'xy') { obj.rotation.set(0, 0, rot); }
        else if (p === 'yz') { obj.rotation.set(0, Math.PI/2, rot); }
        else { obj.rotation.set(Math.PI/2, 0, rot); } // zx default

        return obj;
      }

      function addAxisHelper(size=1, colors={x:0xff0000,y:0x00ff00,z:0x0000ff}) {
        const group = new THREE.Group();
        const axes = [
          {dir:new THREE.Vector3(1,0,0), color:colors.x},
          {dir:new THREE.Vector3(0,1,0), color:colors.y},
          {dir:new THREE.Vector3(0,0,1), color:colors.z},
        ];
        for (const a of axes) {
          const geom = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0,0,0), a.dir.clone().multiplyScalar(size)
          ]);
          const mat = new THREE.LineBasicMaterial({ color:a.color });
          const line = new THREE.Line(geom, mat);
          group.add(line);
        }
        return group;
      }

      function makeGrid(rect) {
        const sizeU = rect.sizeU ?? 10;
        const sizeV = rect.sizeV ?? 10;
        const divisionsU = rect.divisionsU ?? 10;
        const divisionsV = rect.divisionsV ?? 10;
        const color = rect.color ?? 0x444444;
        const opacity = rect.opacity ?? 0.3;

        const grid = new THREE.GridHelper(sizeU, divisionsU, color, color);
        grid.scale.set(1, sizeV / sizeU, 1);
        grid.material.transparent = true;
        grid.material.opacity = opacity;

        const plane = rect.plane ?? 'zx';
        const obj = new THREE.Object3D();
        obj.add(grid);

        if (plane === 'xy') obj.rotation.set(0, 0, 0);
        else if (plane === 'yz') obj.rotation.set(0, Math.PI/2, 0);
        else obj.rotation.set(Math.PI/2, 0, 0);

        if (rect.position) obj.position.set(rect.position.x||0, rect.position.y||0, rect.position.z||0);
        return obj;
      }

      function fitCameraToScene(padding = 1.2) {
        controls.reset();
        const box = new THREE.Box3().setFromObject(scene);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
        cameraZ *= padding;
        camera.position.set(center.x + cameraZ, center.y + cameraZ, center.z + cameraZ);
        controls.target.copy(center);
        controls.update();
      }

      let nodeById = new Map();
      function buildScene(data) {
        nodeGroup.clear();
        edgeGroup.clear();
        labelGroup.clear();
        auxiliaryGroup.clear();
        nodeById.clear();
        const sphereGeom = new THREE.SphereGeometry(0.2, 16, 16);
        const sphereMat = new THREE.MeshStandardMaterial({ color:0x80b0ff });

        for (const n of (data.nodes || [])) {
          const x = n.position?.x ?? 0, y = n.position?.y ?? 0, z = n.position?.z ?? 0;
          const mesh = new THREE.Mesh(sphereGeom, sphereMat.clone());
          mesh.position.set(x, y, z);
          mesh.userData.nodeId = n.id;
          nodeGroup.add(mesh);
          nodeById.set(n.id, mesh);

          if (n.label) {
            const labelObj = makeLabelPlane(n.label.text ?? String(n.id), n.label, n.id);
            labelObj.position.set(x, y, z);
            labelGroup.add(labelObj);
          }
        }

        const lineMat = new THREE.LineBasicMaterial({ color:0x88aaff });
        for (const e of (data.edges || [])) {
          const s = nodeById.get(e.source);
          const t = nodeById.get(e.target);
          if (!s || !t) continue;
          const geom = new THREE.BufferGeometry().setFromPoints([s.position.clone(), t.position.clone()]);
          const line = new THREE.Line(geom, lineMat);
          edgeGroup.add(line);
        }

        for (const aux of (data.auxiliary || [])) {
          if (aux.type === "axis") {
            const size = aux.size ?? 1;
            const colors = {
              x: aux.colors?.x ?? 0xff0000,
              y: aux.colors?.y ?? 0x00ff00,
              z: aux.colors?.z ?? 0x0000ff
            };
            const axis = addAxisHelper(size, colors);
            if (aux.position) axis.position.set(aux.position.x||0, aux.position.y||0, aux.position.z||0);
            auxiliaryGroup.add(axis);
          } else if (aux.type === "grid" && aux.grid) {
            auxiliaryGroup.add(makeGrid(aux.grid));
          } else if (aux.type === "label" && aux.text) {
            const labelObj = makeLabelPlane(aux.text, aux.options || {});
            if (aux.position) labelObj.position.set(aux.position.x||0, aux.position.y||0, aux.position.z||0);
            auxiliaryGroup.add(labelObj);
          }
        }

        const ambient = new THREE.AmbientLight(0xffffff, 0.7);
        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(1,1,1);
        scene.add(ambient, dir);
      }

      function showNode(node) {
        const nodePane = document.getElementById('node');
        nodePane.innerHTML = '';
        const wrap = document.createElement('div');
        wrap.className = 'node-item';
        wrap.textContent = JSON.stringify(node, null, 2);
        nodePane.appendChild(wrap);
        // switch tab if mobile
        if (window.innerWidth <= 600) {
          document.querySelectorAll('#tabs button').forEach(b => b.classList.remove('active'));
          const btn = document.querySelector('#tabs button[data-tab="node"]');
          btn.classList.add('active');
          document.querySelectorAll('#tab-content .tab-pane').forEach(p => p.classList.remove('active'));
          document.getElementById('node').classList.add('active');
        }
      }

      function showErrors(errors) {
        const el = document.getElementById('errors');
        el.innerHTML = '';
        for (const m of errors) {
          const div = document.createElement('div');
          div.className = 'error-item';
          div.textContent = m;
          el.appendChild(div);
        }
        if (window.innerWidth <= 600) {
          document.querySelectorAll('#tabs button').forEach(b => b.classList.remove('active'));
          const btn = document.querySelector('#tabs button[data-tab="errors"]');
          btn.classList.add('active');
          document.querySelectorAll('#tab-content .tab-pane').forEach(p => p.classList.remove('active'));
          document.getElementById('errors').classList.add('active');
        }
      }

      function showMeta(meta) {
        const el = document.getElementById('meta');
        el.innerHTML = '';
        for (const [k,v] of Object.entries(meta || {})) {
          const div = document.createElement('div');
          div.className = 'meta-item';
          div.textContent = `${k}: ${typeof v === 'object' ? JSON.stringify(v) : v}`;
          el.appendChild(div);
        }
        if (window.innerWidth <= 600) {
          document.querySelectorAll('#tabs button').forEach(b => b.classList.remove('active'));
          const btn = document.querySelector('#tabs button[data-tab="meta"]');
          btn.classList.add('active');
          document.querySelectorAll('#tab-content .tab-pane').forEach(p => p.classList.remove('active'));
          document.getElementById('meta').classList.add('active');
        }
      }

      async function loadFromUrl(url) {
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error("HTTP " + res.status);
          const data = await res.json();
          runValidation(data);
          buildScene(data);
          fitCameraToScene();
          snapshotInitialView();
        } catch (err) {
          alert("URL読み込み失敗: " + err.message);
        }
      }

      document.getElementById('btnLoad').onclick = () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json,application/json';
        input.onchange = async () => {
          const file = input.files[0];
          if (!file) return;
          try {
            const text = await file.text();
            const data = JSON.parse(text);
            runValidation(data);
            buildScene(data);
            fitCameraToScene();
            snapshotInitialView();
          } catch (err) {
            alert("JSONの読み込みに失敗しました: " + err.message);
          }
        };
        input.click();
      };

      const ajv = new Ajv({ allErrors: true, strict: false });
      ajv.addFormat("uri", true);
      ajv.addFormat("uri-reference", true);
      ajv.addFormat("uri-template", true);
      ajv.addFormat("json-pointer", true);
      ajv.addFormat("relative-json-pointer", true);

      let validateModel = null;
      let validateManifest = null;

      async function loadSchemas() {
        try {        

      const fetchJsonNoCache = async (url) => {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error(`${url} HTTP ${res.status}`);
        const txt = await res.text();
        try { return JSON.parse(txt); }
        catch (e) {
          console.error('Schema fetch returned non-JSON. url=', url, 'head=', txt.slice(0,200));
          throw e;
        }
      };
      const schemaBase = 'https://q2t-project.github.io/digidiorama';
      const [modelSchema, manifestSchema] = await Promise.all([
        fetchJsonNoCache(`${schemaBase}/digidiorama.schema.json`),
        fetchJsonNoCache(`${schemaBase}/manifest.schema.json`)
      ]);

          validateModel = ajv.compile(modelSchema);
          validateManifest = ajv.compile(manifestSchema);
        } catch(err) {
          console.warn('Schema load failed, fallback to minimal schema', err);
          const fallback = {
            type:'object',
            properties:{
              meta:{type:'object'},
              nodes:{type:'array'},
              edges:{type:'array'},
              auxiliary:{type:'array'}
            },
            required:['meta','nodes','edges']
          };
          validateModel = ajv.compile(fallback);
        }
      }

      function extraChecks(data) {
        const msgs = [];
        const ids = new Set();
        for (const n of (data.nodes || [])) {
          if (!n || typeof n.id !== 'string') continue;
          if (ids.has(n.id)) msgs.push(`Duplicate node id: ${n.id}`);
          ids.add(n.id);
        }
        for (const e of (data.edges || [])) {
          if (e && typeof e.source === 'string' && !ids.has(e.source)) msgs.push(`Edge source not found: ${e.source}`);
          if (e && typeof e.target === 'string' && !ids.has(e.target)) msgs.push(`Edge target not found: ${e.target}`);
        }
        return msgs;
      }

      function runValidation(data) {
        const msgs = [];
        if (typeof validateModel === 'function') {
          const ok = validateModel(data);
          if (!ok) {
            msgs.push(...validateModel.errors.map(e => `${e.instancePath || '/'} ${e.message}`));
          }
        } else if (typeof validate === 'function') {
          const ok = validate(data);
          if (!ok) {
            msgs.push(...validate.errors.map(e => `${e.instancePath || '/'} ${e.message}`));
          }
        }
        msgs.push(...extraChecks(data));
        showErrors(msgs);
        showMeta(data.meta || {});
      }

      // UI events
      document.getElementById('btnUrlLoad').onclick = async () => {
        const url = prompt("モデルJSONの URL を入力してください:");
        if (url) await loadFromUrl(url);
      };

      const tabs = document.querySelectorAll('#tabs button');
      tabs.forEach(btn => {
        btn.onclick = () => {
          document.querySelectorAll('#tabs button').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          document.querySelectorAll('#tab-content .tab-pane').forEach(p => p.classList.remove('active'));
          const id = btn.getAttribute('data-tab');
          document.getElementById(id).classList.add('active');
        };
      });
      if (window.innerWidth <= 600) {
        document.querySelector('#node').classList.add('active');
      }

      // picking
      container.addEventListener('pointerdown', (e) => {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = - ((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(nodeGroup.children, true);
        if (intersects.length > 0) {
          const mesh = intersects[0].object;
          if (mesh.userData.nodeId) {
            const node = nodeById.get(mesh.userData.nodeId).userData;
            showNode(node);
          }
        }
      });

      // mobile panel gestures
      const panel = document.getElementById('panel');
      const fab = document.getElementById('fab');
      fab.onclick = () => {
        panel.classList.toggle('open');
        panel.classList.toggle('closed');
      };

      let touchStartX = 0, touchStartY = 0;
      window.addEventListener("touchstart", e => {
        if (!e.touches || e.touches.length === 0) return;
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }, { passive:true });
      window.addEventListener("touchend", e => {
        if (!e.changedTouches || e.changedTouches.length === 0) return;
        const dx = e.changedTouches[0].clientX - touchStartX;
        const dy = e.changedTouches[0].clientY - touchStartY;
        if (Math.abs(dx) > 50 && window.innerWidth > 600) {
          if (dx < 0) panel.classList.add('open'); else panel.classList.remove('open');
        }
        if (Math.abs(dy) > 50 && window.innerWidth <= 600) {
          if (dy < 0) panel.classList.add('open'); else panel.classList.remove('open');
        }
      }, { passive:true });

      document.getElementById('btnReset').onclick = () => { fitCameraToScene(); };
      // Keyboard shortcuts: F = Fit, R = Reset-to-initial
      window.addEventListener('keydown', (e) => {
        if (e.repeat) return;
        const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
        if (tag === 'input' || tag === 'textarea') return;
        if (e.key === 'f' || e.key === 'F') { fitCameraToScene(); }
        if (e.key === 'r' || e.key === 'R') { resetView(); }
      });

      // Add helpful titles
      document.getElementById('btnReset')?.setAttribute('title', 'Fキー: 全体にフィット');
      document.getElementById('btnLoad')?.setAttribute('title', 'JSONファイルを読み込む');
      document.getElementById('btnUrlLoad')?.setAttribute('title', 'URLからJSONを読み込む');
      document.getElementById('btnLayers')?.setAttribute('title', 'レイヤ表示を切替');

      document.getElementById('btnLayers').onclick = () => {
        const dd = document.getElementById('layersDropdown');
        dd.style.display = dd.style.display === 'none' ? 'block' : 'none';
      };
      document.getElementById('toggle-nodes').onchange = (ev) => { nodeGroup.visible = ev.target.checked; };
      document.getElementById('toggle-edges').onchange = (ev) => { edgeGroup.visible = ev.target.checked; };
      document.getElementById('toggle-labels').onchange = (ev) => { labelGroup.visible = ev.target.checked; };
      document.getElementById('toggle-aux').onchange = (ev) => { auxiliaryGroup.visible = ev.target.checked; };

      // locale & schema
      async function loadLocale(lang='ja') {
        // i18n placeholder (extend as needed)
        const map = {
          ja: { reset:'再描画' },
          en: { reset:'Reset' }
        }[lang] || {};
        for (const el of document.querySelectorAll('[data-i18n]')) {
          const key = el.getAttribute('data-i18n');
          if (map[key]) el.textContent = map[key];
        }
      }

      async function fetchJson(path) {
        const res = await fetch(path);
        return res.json();
      }

      loadSchemas();
      loadLocale('ja');

      const ro = new ResizeObserver(() => {
        const { clientWidth:w, clientHeight:h } = container;
        renderer.setSize(w, h, true);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      });
      ro.observe(container);

      function animate() {
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();
    </script>
  </body>
</html>
