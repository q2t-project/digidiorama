<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>digidiorama viewer</title>

  <!-- favicon（404対策・プロジェクトの assets/ に配置想定） -->
  <link rel="icon" href="./assets/favicon.ico" />

  <style>
    :root{
      --bg:#0e1522;
      --panel:#0f1a2b;
      --text:#e8eefc;
      --muted:#a8b3c9;
      --accent:#6aa9ff;
      --ok:#41d1a7;
      --warn:#ffb454;
      --err:#ff6464;
      --btn:#16233b;
      --btn-hover:#1c2b4d;
      --badge:#23365e;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;padding:0;background:var(--bg);color:var(--text);font:14px/1.6 ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP","Hiragino Kaku Gothic ProN","Meiryo","Helvetica Neue",Arial,sans-serif}
    a{color:var(--accent);text-decoration:none}
    .toolbar{
      position:fixed;inset:0 0 auto 0;height:56px;display:flex;gap:10px;
      align-items:center;padding:8px 12px;background:#0e1522ee;backdrop-filter:saturate(150%) blur(4px);z-index:10;
      border-bottom:1px solid #0f2544;
    }
    .spacer{flex:1}
    .btn{
      display:inline-flex;align-items:center;gap:.5rem;height:40px;padding:0 14px;border-radius:10px;border:1px solid #223456;
      background:var(--btn);color:var(--text);cursor:pointer;user-select:none;
    }
    .btn:hover{background:var(--btn-hover)}
    .btn.active{outline:2px solid var(--accent)}
    .select{height:40px;border-radius:10px;border:1px solid #223456;background:var(--btn);color:var(--text);padding:0 10px}
    #stage{position:fixed;inset:56px 0 24px 0}
    #hud{position:fixed;inset:auto 0 0 0;height:24px;display:flex;align-items:center;gap:12px;padding:2px 10px;color:var(--muted);background:#0e1522cc;border-top:1px solid #0f2544;font-size:12px}
    .menu{
      position:relative
    }
    .menu > .panel{
      position:absolute;right:0;top:48px;background:var(--panel);border:1px solid #223456;border-radius:12px;min-width:220px;
      box-shadow:0 10px 30px #0006;padding:10px;display:none;z-index:20
    }
    .menu.open > .panel{display:block}
    .row{display:flex;align-items:center;justify-content:space-between;padding:4px 0}
    .row label{color:var(--muted)}
    .switch{width:44px;height:24px;border-radius:999px;background:#1c2b4d;position:relative;cursor:pointer;border:1px solid #223456}
    .switch input{appearance:none;width:0;height:0;opacity:0;position:absolute}
    .switch i{
      position:absolute;top:2px;left:2px;width:18px;height:18px;border-radius:999px;background:#8898b3;transition:transform .18s ease, background .18s ease
    }
    .switch input:checked + i{transform:translateX(20px);background:#9fe870}
    .meta{padding:6px 10px;border-radius:10px;background:var(--badge);color:#cfe1ff;font-size:12px}
    .badge{padding:2px 8px;border-radius:999px;background:#1e2c49; color:#cfe1ff;font-size:12px}
    .vis-chip{display:inline-flex;gap:6px;align-items:center}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    canvas{display:block}
  </style>
</head>
<body>
  <div class="toolbar">
    <select id="fileSelect" class="select" title="デモデータ">
      <option value="">Loading…</option>
    </select>

    <button id="btnLang" class="btn" title="言語切替">日本語</button>
    <button id="btnReset" class="btn" title="初期ビューへ戻す">Reset</button>
    <button id="btnFit" class="btn" title="ノードにフィット">Fit</button>

    <div class="menu" id="layersMenu">
      <button id="btnLayers" class="btn">Layers ▾</button>
      <div class="panel">
        <div class="row"><label>Nodes</label>
          <span class="vis-chip">
            <span id="count-nodes" class="badge">0</span>
            <span class="switch"><input id="toggle-nodes" type="checkbox" checked><i></i></span>
          </span>
        </div>
        <div class="row"><label>Edges</label>
          <span class="vis-chip">
            <span id="count-edges" class="badge">0</span>
            <span class="switch"><input id="toggle-edges" type="checkbox" checked><i></i></span>
          </span>
        </div>
        <div class="row"><label>Labels</label>
          <span class="switch"><input id="toggle-labels" type="checkbox" checked><i></i></span>
        </div>
        <div class="row"><label>Aux</label>
          <span class="switch"><input id="toggle-aux" type="checkbox" checked><i></i></span>
        </div>
      </div>
    </div>

    <div class="spacer"></div>

    <span class="meta" id="metaTitle">—</span>
  </div>

  <div id="stage"></div>

  <div id="hud">
    <span>MIT © q2t-project</span>
    <span id="version" class="mono"></span>
    <span id="counts" class="mono"></span>
    <span id="msg" class="mono"></span>
  </div>

  <!-- Three.js + controls はローカルの scripts/ 配下から相対import -->
  <script type="module">
    /******************************************************************
     * Imports
     ******************************************************************/
    import * as THREE from './scripts/three.module.js';
    import { OrbitControls } from './scripts/OrbitControls.js';
    // Ajv ESM(2020 bundle)。存在しない場合は try/catch でスキップ可能に
    let Ajv = null;
    try {
      const m = await import('./scripts/2020.bundle.mjs').catch(()=>import('./scripts/2020bundle.mjs')).catch(()=>null);
      Ajv = m?.default ?? m?.Ajv ?? null;
    } catch(_){ Ajv = null }

    /******************************************************************
     * Globals
     ******************************************************************/
    const NS = 'ddv:v2:';                   // localStorage 名前空間
    const VERSION = 'v2.0.0';               // 表示用バージョン
    document.getElementById('version').textContent = ` ${VERSION}`;

    // Three.js essentials
    const container = document.getElementById('stage');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0e1522);
    const camera = new THREE.PerspectiveCamera(60, 16/9, 0.1, 1e7);
    const renderer = new THREE.WebGLRenderer({antialias:true, powerPreference:'high-performance'});
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // groups
    const root = new THREE.Group();
    const nodeGroup = new THREE.Group();
    const edgeGroup = new THREE.Group();
    const labelGroup = new THREE.Group();
    const auxiliaryGroup = new THREE.Group();
    root.add(nodeGroup, edgeGroup, labelGroup, auxiliaryGroup);
    scene.add(root);

    // lights
    {
      const a = new THREE.AmbientLight(0xffffff, .45);
      const d = new THREE.DirectionalLight(0xffffff, .6);
      d.position.set(1,2,3);
      scene.add(a, d);
    }

    // viewport / resize
    function resize(){
      const w = container.clientWidth, h = container.clientHeight;
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h, false);
    }
    new ResizeObserver(resize).observe(container);

    // HUD
    const $msg = document.getElementById('msg');
    const $metaTitle = document.getElementById('metaTitle');
    const $counts = document.getElementById('counts');
    const $cn = (id)=>document.getElementById(id);

    // menu toggle
    const layersMenu = document.getElementById('layersMenu');
    document.getElementById('btnLayers').addEventListener('click', ()=>{
      layersMenu.classList.toggle('open');
    });
    window.addEventListener('click', (e)=>{
      if (!layersMenu.contains(e.target) && layersMenu.classList.contains('open')){
        layersMenu.classList.remove('open');
      }
    });

    /******************************************************************
     * Home pose / layer defaults
     ******************************************************************/
    let home = {
      pos: new THREE.Vector3(300, 300, 300),
      target: new THREE.Vector3(0,0,0),
      up: new THREE.Vector3(0,0,1),
      fov: 60
    };
    const layersDefault = { nodes:true, edges:true, labels:true, aux:true };

    function rememberHomeFromCurrentView(){
      home.pos.copy(camera.position);
      home.target.copy(controls.target);
      home.up.copy(camera.up);
      home.fov = camera.fov;
    }
    function resetView(){
      camera.fov = home.fov;
      camera.position.copy(home.pos);
      camera.up.copy(home.up);
      camera.updateProjectionMatrix();
      controls.target.copy(home.target);
      controls.update();

      // レイヤーを既定に
      const pairs = [
        ['toggle-nodes',  nodeGroup,      layersDefault.nodes],
        ['toggle-edges',  edgeGroup,      layersDefault.edges],
        ['toggle-labels', labelGroup,     layersDefault.labels],
        ['toggle-aux',    auxiliaryGroup, layersDefault.aux],
      ];
      for (const [id, group, def] of pairs){
        const el = $cn(id); if (el) el.checked = def;
        group.visible = def;
      }
      saveLayers();
    }

    /******************************************************************
     * Fit camera
     ******************************************************************/
    function fitCameraToScene(padding=1.25){
      const box = new THREE.Box3().setFromObject(root);
      if (box.isEmpty()){
        camera.position.set(300,300,300);
        controls.target.set(0,0,0);
        controls.update();
        return;
      }
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x,size.y,size.z) || 1;
      const fov = camera.fov * Math.PI/180;
      let dist = Math.abs(maxDim/2 / Math.tan(fov/2));
      dist *= padding;
      camera.position.set(center.x + dist, center.y + dist, center.z + dist);
      controls.target.copy(center);
      controls.update();
    }
    function fitCameraToNodes(nodes, padding=1.25){
      const box = new THREE.Box3();
      if (Array.isArray(nodes) && nodes.length){
        for (const n of nodes){
          if (n?.position && n.position.length===3){
            box.expandByPoint(new THREE.Vector3(...n.position));
          }
        }
      }
      if (box.isEmpty()){
        fitCameraToScene(padding);
        return;
      }
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x,size.y,size.z) || 1;
      const fov = camera.fov * Math.PI/180;
      let dist = Math.abs(maxDim/2 / Math.tan(fov/2));
      dist *= padding;
      camera.position.set(center.x + dist, center.y + dist, center.z + dist);
      controls.target.copy(center);
      controls.update();
    }

    /******************************************************************
     * Data loading (manifest + model)
     ******************************************************************/
    async function loadManifest(){
      // ルート or assets に置かれた manifest を読む
      const res = await fetch('./assets/manifest.json').catch(()=>fetch('./manifest.json'));
      if (!res.ok) throw new Error('manifest not found');
      return res.json();
    }
    async function loadDigidiorama(path){
      const bust = `?v=${Date.now()}`;
      const res = await fetch(path + (path.includes('?')?'&':'?') + 'v=' + Date.now());
      if (!res.ok) throw new Error(`load error: ${path}`);
      return res.json();
    }

    /******************************************************************
     * AJV validation (optional)
     ******************************************************************/
    let validateModel = null, validateManifest = null;
    async function loadSchemas(){
      try{
        if (!Ajv) throw new Error('Ajv not available');
        const [modelSchema, manifestSchema] = await Promise.all([
          fetch('./digidiorama.schema.json').then(r=> r.ok ? r.json() : Promise.reject(new Error('model schema not found'))),
          fetch('./manifest.schema.json').then(r=> r.ok ? r.json() : Promise.reject(new Error('manifest schema not found')))
        ]);
        const ajv = new Ajv({ strict:false, allErrors:true, allowUnionTypes:true });
        validateModel = ajv.compile(modelSchema);
        validateManifest = ajv.compile(manifestSchema);
      }catch(err){
        console.warn('Schema load failed, fallback to minimal schema', err);
        const ajv = Ajv ? new Ajv({strict:false}) : null;
        const fallback = { type:'object', properties:{ meta:{type:'object'}, nodes:{type:'array'}, edges:{type:'array'}, auxiliary:{type:'array'} } };
        validateModel = ajv ? ajv.compile(fallback) : (data)=>true;
        validateManifest = ajv ? ajv.compile({type:'object'}) : (data)=>true;
      }
    }

    function runValidation(data){
      const msgs = [];
      if (validateModel){
        const ok = validateModel(data);
        if (!ok) msgs.push(...validateModel.errors.map(e=> `${e.instancePath || '/'} ${e.message}`));
      }
      // 追加の整合チェック（ID重複など軽く）
      msgs.push(...extraChecks(data));
      showErrors(msgs);
    }
    function extraChecks(data){
      const msgs = [];
      const ids = new Set();
      if (Array.isArray(data?.nodes)){
        for (const n of data.nodes){
          if (!n || typeof n.id !== 'string') continue;
          if (ids.has(n.id)) msgs.push(`Duplicate node id: ${n.id}`);
          ids.add(n.id);
        }
      }
      if (Array.isArray(data?.edges)){
        const idset = new Set((data.nodes||[]).map(n=>n.id));
        for (const e of data.edges){
          if (e && typeof e.source==='string' && !idset.has(e.source)) msgs.push(`Edge source not found: ${e.source}`);
          if (e && typeof e.target==='string' && !idset.has(e.target)) msgs.push(`Edge target not found: ${e.target}`);
        }
      }
      return msgs;
    }
    function showErrors(errs){
      if (!errs || !errs.length){ $msg.textContent=''; return; }
      $msg.textContent = '⚠ ' + errs.slice(0,3).join(' | ') + (errs.length>3 ? ` …(+${errs.length-3})`:'');
    }

    /******************************************************************
     * Scene building helpers
     ******************************************************************/
    const NODE_GEOM = new THREE.SphereGeometry(2, 10, 10);
    const NODE_MAT  = new THREE.MeshStandardMaterial({color:0x88aaff, roughness:.35, metalness:.1});

    function makeLabelSprite(text, attr={}){
      const fontSize = Math.max(12, attr.fontSize||24);
      const color = attr.color || '#ffffff';
      const bg = attr.background || null;

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const padding = Math.round(fontSize*0.3);
      ctx.font = `bold ${fontSize}px "Segoe UI", "Noto Sans JP", sans-serif`;
      const metrics = ctx.measureText(text);
      const w = Math.ceil(metrics.width)+padding*2, h = fontSize+padding*2;
      canvas.width = w; canvas.height = h;

      // paint
      if (bg){
        ctx.fillStyle = bg; ctx.fillRect(0,0,w,h);
      }
      ctx.font = `bold ${fontSize}px "Segoe UI", "Noto Sans JP", sans-serif`;
      ctx.fillStyle = color;
      ctx.textBaseline = 'middle';
      ctx.fillText(text, padding, h/2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.minFilter = THREE.LinearFilter;
      const mat = new THREE.SpriteMaterial({map:tex, transparent: !!bg});
      const spr = new THREE.Sprite(mat);
      // 尺度調整（1px=0.5Unit程度）
      spr.scale.set(w*0.5, h*0.5, 1);
      return spr;
    }

    function clearGroup(grp){
      for (let i=grp.children.length-1; i>=0; i--){
        const o = grp.children[i];
        if (o.geometry) o.geometry.dispose();
        if (o.material){
          if (Array.isArray(o.material)) o.material.forEach(m=>m.dispose()); else o.material.dispose();
        }
        if (o.texture) o.texture.dispose?.();
        grp.remove(o);
      }
    }

    function buildScene(data){
      clearGroup(nodeGroup); clearGroup(edgeGroup); clearGroup(labelGroup); clearGroup(auxiliaryGroup);

      const mapPos = new Map();
      if (Array.isArray(data?.nodes)){
        for (const n of data.nodes){
          const p = Array.isArray(n.position) && n.position.length===3 ? n.position : [0,0,0];
          mapPos.set(n.id, new THREE.Vector3(p[0], p[1], p[2]));
          const mesh = new THREE.Mesh(NODE_GEOM, NODE_MAT.clone());
          mesh.position.set(p[0], p[1], p[2]);
          nodeGroup.add(mesh);

          // label
          const label = (n.label ?? n.id ?? '').toString();
          if (label){
            const spr = makeLabelSprite(label, n.labelAttr||{});
            spr.position.set(p[0], p[1], p[2]);
            spr.position.y += 6;
            labelGroup.add(spr);
          }
        }
      }

      if (Array.isArray(data?.edges)){
        const matLine = new THREE.LineBasicMaterial({color:0x88ffbb, transparent:true, opacity:.8});
        for (const e of data.edges){
          const a = mapPos.get(e.source), b = mapPos.get(e.target);
          if (!a || !b) continue;
          const geo = new THREE.BufferGeometry().setFromPoints([a,b]);
          const line = new THREE.Line(geo, matLine);
          edgeGroup.add(line);
        }
      }

      // Meta / counts 表示
      showMeta(data?.meta||{}, data);

      // ノードにフィット → これをホームとして記憶
      fitCameraToNodes(data?.nodes||[]);
      rememberHomeFromCurrentView();
      saveLayers(); // 現在値を保存（初回）
    }

    function showMeta(meta={}, data={}){
      const title = meta.title || '—';
      $metaTitle.textContent = title;

      const cn = Array.isArray(data.nodes) ? data.nodes.length : 0;
      const ce = Array.isArray(data.edges) ? data.edges.length : 0;
      $cn('count-nodes').textContent = String(cn);
      $cn('count-edges').textContent = String(ce);
      $counts.textContent = ` nodes:${cn} | edges:${ce}`;
    }

    /******************************************************************
     * Layers toggle + persistence
     ******************************************************************/
    const LAYERS_KEYS = ['nodes','edges','labels','aux'];
    function loadLayers(){
      try{
        const raw = localStorage.getItem(NS+'layers');
        if (!raw) return;
        const v = JSON.parse(raw);
        LAYERS_KEYS.forEach(k=>{
          if (k in v){
            const el = $cn('toggle-'+k);
            if (el){ el.checked = !!v[k]; }
            if (k==='nodes') nodeGroup.visible = !!v[k];
            if (k==='edges') edgeGroup.visible = !!v[k];
            if (k==='labels') labelGroup.visible = !!v[k];
            if (k==='aux') auxiliaryGroup.visible = !!v[k];
          }
        });
      }catch(_){}
    }
    function saveLayers(){
      const v = {
        nodes: !!$cn('toggle-nodes')?.checked,
        edges: !!$cn('toggle-edges')?.checked,
        labels:!!$cn('toggle-labels')?.checked,
        aux:   !!$cn('toggle-aux')?.checked
      };
      try{ localStorage.setItem(NS+'layers', JSON.stringify(v)); }catch(_){}
    }
    // wire toggles
    $cn('toggle-nodes').addEventListener('change', e=>{ nodeGroup.visible = e.target.checked; saveLayers(); });
    $cn('toggle-edges').addEventListener('change', e=>{ edgeGroup.visible = e.target.checked; saveLayers(); });
    $cn('toggle-labels').addEventListener('change', e=>{ labelGroup.visible = e.target.checked; saveLayers(); });
    $cn('toggle-aux')  .addEventListener('change', e=>{ auxiliaryGroup.visible = e.target.checked; saveLayers(); });

    /******************************************************************
     * UI: lang, fit, reset, select
     ******************************************************************/
    let currentData = null;
    document.getElementById('btnFit').addEventListener('click', ()=>{
      if (currentData) fitCameraToNodes(currentData.nodes);
      else fitCameraToScene();
    });
    document.getElementById('btnReset').addEventListener('click', resetView);

    // 言語切替（ダミー・ボタン表示だけ切替）
    const btnLang = document.getElementById('btnLang');
    btnLang.addEventListener('click', ()=>{
      const now = btnLang.textContent.trim();
      const next = now==='日本語' ? 'English' : '日本語';
      btnLang.textContent = next;
      try{ localStorage.setItem(NS+'lang', next); }catch(_){}
    });
    (function initLang(){
      const v = localStorage.getItem(NS+'lang');
      if (v) btnLang.textContent = v;
    })();

    const select = document.getElementById('fileSelect');
    select.addEventListener('change', async ()=>{
      if (!select.value) return;
      try{
        const data = await loadDigidiorama(select.value);
        currentData = data;
        runValidation(data);
        buildScene(data);
        try{ localStorage.setItem(NS+'lastFile', select.value); }catch(_){}
      }catch(err){
        console.error(err);
        $msg.textContent = '✖ ' + err.message;
      }
    });

    /******************************************************************
     * Bootstrap
     ******************************************************************/
    async function bootstrap(){
      resize();
      await loadSchemas().catch(()=>{});
      // manifest から select を構築
      let items = [];
      try{
        const mani = await loadManifest();
        if (validateManifest && !validateManifest(mani)){
          console.warn('manifest validation errors', validateManifest.errors);
        }
        // manifest { groups:[{title, files:[{path,title}]}] }
        mani.groups?.forEach(g=>{
          (g.files||[]).forEach(f=>{
            items.push({ path:f.path, title:f.title || f.path });
          });
        });
      }catch(_){
        // フォールバック（smoke test のみ）
        items = [
          { path:'./assets/data/smoke_test.json', title:'Smoke Test' }
        ];
      }
      // select構築
      select.innerHTML = '';
      for (const it of items){
        const opt = document.createElement('option');
        opt.value = it.path;
        opt.textContent = it.title;
        select.appendChild(opt);
      }

      // 直近の選択を復元
      const last = localStorage.getItem(NS+'lastFile');
      if (last && items.some(i=>i.path===last)) select.value = last;

      // レイヤー復元
      loadLayers();

      // 最初のロード
      if (select.value) select.dispatchEvent(new Event('change'));
      else if (items[0]){ select.value = items[0].path; select.dispatchEvent(new Event('change')); }

      animate();
    }

    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    bootstrap();
  </script>
</body>
</html>
