<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>digidiorama viewer/</title>
<link rel="icon" href="data:,">
<style>
  :root { --bg:#0b1020; --fg:#e6edf3; --accent:#5aa9ff; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui}
  #app{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr}
  header{display:flex;gap:.5rem;align-items:center;padding:.5rem .75rem;background:#0e142a;border-bottom:1px solid #1d2748}
  header h1{font-size:14px;margin:0;font-weight:600}
  header .spacer{flex:1}
  header button{appearance:none;border:1px solid #2a3969;background:#131a33;color:var(--fg);padding:.4rem .8rem;border-radius:.4rem;cursor:pointer;min-height:36px;font-size:.9rem}
  header button:hover{border-color:#39529c;background:#1a2347}

  /* メインは1カラム。パネルは絶対配置（重ねる） */
  #main{position:relative;overflow:hidden}
  #viewer{position:absolute;inset:0;overflow:hidden}

  /* 右スライドパネル：初期は非表示（オーバーレイ） */
  #panel{
    position:absolute; right:0; top:0; height:100%; width:250px;
    background:#10172c; border-left:1px solid #1d2748; padding:.5rem;
    overflow:auto; transform:translateX(100%); transition:transform .3s ease; z-index:10;
  }
  #panel.open{ transform:translateX(0) }
  #tabs{display:none;margin-bottom:.5rem}
  #tabs button{flex:1;padding:.5rem;border:none;background:#2a3969;color:#fff;border-radius:.3rem;cursor:pointer}
  #tabs button.active{background:var(--accent)}
  .tab-pane{display:block}

  /* 右下メニュー(FAB) */
  #fab{
    position:absolute; right:.75rem; bottom:.75rem; width:56px; height:56px; border-radius:50%;
    background:var(--accent); color:#fff; border:none; font-size:24px; cursor:pointer; z-index:20;
  }

  /* 右上インフォパネル：必要時のみ */
  .info-toggle{position:absolute; right:4.75rem; bottom:.75rem; z-index:20}
  .info-panel{
    position:absolute; right:0; top:0; width:280px; height:100%;
    background:rgba(0,0,0,.8); color:#fff; overflow:auto; display:none; z-index:15;
  }
  .info-panel.active{display:block}

  .credit{position:absolute; right:.5rem; bottom:.5rem; font-size:11px; opacity:.7}
  canvas{display:block;width:100%;height:100%}

  @media(max-width:600px){
    header button{font-size:.8rem;padding:.3rem .6rem;min-height:32px}
    /* スマホは下からスライド */
    #panel{left:0;right:auto;bottom:0;top:auto;width:100%;height:40%;border-left:none;border-top:1px solid #1d2748;transform:translateY(100%)}
    #panel.open{transform:translateY(0)}
    #tabs{display:flex;gap:.5rem}
    #tab-content .tab-pane{display:none}
    #tab-content .tab-pane.active{display:block}
  }
</style>

<script type="importmap">
{
  "imports":{
    "three":"https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/":"https://unpkg.com/three@0.160.0/examples/jsm/",
    "ajv":"https://esm.sh/ajv@8/dist/2020?bundle"
  }
}
</script>
</head>
<body>
<div id="app">
  <header>
    <h1>デジジオラマ</h1>
    <div class="spacer"></div>
    <button id="btnLoad">File読込</button>
    <button id="btnUrlLoad">URL読込</button>
    <button id="btnReset" data-i18n="reset">再描画</button>
    <div id="layersMenu" style="position:relative;">
      <button id="btnLayers">レイヤ▼</button>
      <div id="layersDropdown" style="display:none;position:absolute;right:0;top:100%;background:#131a33;border:1px solid #2a3969;padding:.5rem;border-radius:.4rem; z-index:1000; max-height:70vh; overflow-y:auto;">
        <label><input type="checkbox" id="toggle-nodes" checked> Nodes</label><br>
        <label><input type="checkbox" id="toggle-edges" checked> Edges</label><br>
        <label><input type="checkbox" id="toggle-labels" checked> Labels</label><br>
        <label><input type="checkbox" id="toggle-aux" checked> Auxiliary</label>
      </div>
    </div>
    <div id="infoPanel" class="info-panel"></div>
    <button id="toggleInfo" class="info-toggle">i</button>
  </header>

  <div id="main">
    <div id="viewer"></div>
    <div id="panel"><!-- 初期は閉じてる（openクラスなし） -->
      <div id="tabs">
        <button data-tab="node" class="active">Node</button>
        <button data-tab="errors">Errors</button>
        <button data-tab="meta">Meta</button>
      </div>
      <div id="tab-content">
        <div id="node" class="tab-pane active"></div>
        <div id="errors" class="tab-pane"></div>
        <div id="meta" class="tab-pane"></div>
      </div>
    </div>
    <button id="fab">≡</button>
  </div>
</div>

<div class="credit">MIT © qQt-project / Content © respective authors</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import Ajv from 'ajv';

const container = document.getElementById('viewer');

/* --- Three.js 基本 --- */
const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0b1020);
const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
camera.up.set(0,0,1);
camera.position.set(5,5,5);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({ antialias:true });
const dpr = Math.min(window.devicePixelRatio, 1.5);
renderer.setPixelRatio(dpr);
renderer.setSize(container.clientWidth, container.clientHeight, false);
container.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.zoomSpeed   = window.innerWidth < 600 ? 1.2 : 2;
controls.rotateSpeed = window.innerWidth < 600 ? 0.8 : 1.0;
controls.panSpeed    = window.innerWidth < 600 ? 0.5 : 1.0;
controls.minDistance = 1;
controls.maxDistance = 200;

/* --- 操作中だけ描画 + DPR 0.8 --- */
let animating = false;
function startAnimating(){
  if(!animating){ animating = true; requestAnimationFrame(loop); }
}
controls.addEventListener('start', ()=>{
  renderer.setPixelRatio(0.8); // ドラッグ中は軽く
  renderer.setSize(container.clientWidth, container.clientHeight, false);
  startAnimating();
});
controls.addEventListener('end', ()=>{
  animating = false;
  renderer.setPixelRatio(dpr); // 静止で高精細
  renderer.setSize(container.clientWidth, container.clientHeight, false);
  renderer.render(scene, camera); // 仕上げに1枚
});

function loop(){
  if(!animating) return;
  controls.update();
  updateLabelsVisibility();
  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}

/* --- ライト・グループ --- */
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(5,10,7); scene.add(dir);

const nodeGroup = new THREE.Group();
const edgeGroup = new THREE.Group();
const labelGroup = new THREE.Group();
const auxiliaryGroup = new THREE.Group();
scene.add(edgeGroup, nodeGroup, labelGroup, auxiliaryGroup);

/* --- 初回描画 --- */
render();
function render(){ renderer.render(scene, camera); }

/* --- ラベル生成 & 可視制御 --- */
function makeLabelPlane(text, options={}, nodeId=null){
  const fontSize   = options.fontSize   ?? 32;
  const fontFamily = options.fontFamily ?? 'Arial';
  const color      = options.color      ?? 'white';
  const opacity    = options.opacity    ?? 1.0;
  const background = options.background ?? null;
  const plane      = options.plane      ?? 'zx';
  const direction  = options.direction  ?? 0;
  const worldScale = options.worldScale ?? 0.1;

  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.font = `${fontSize}px ${fontFamily}`;
  const metrics = ctx.measureText(text);
  canvas.width  = metrics.width + 20;
  canvas.height = fontSize * 1.5;
  ctx.font = `${fontSize}px ${fontFamily}`;
  if(background){ ctx.fillStyle = background; ctx.fillRect(0,0,canvas.width,canvas.height); }
  ctx.fillStyle = color; ctx.textAlign='center'; ctx.textBaseline='middle';
  if(!background){
    ctx.lineWidth = Math.max(2, fontSize*0.12);
    ctx.strokeStyle = 'rgba(0,0,0,0.9)'; ctx.lineJoin='round'; ctx.strokeText(text, canvas.width/2, canvas.height/2);
  }
  ctx.fillText(text, canvas.width/2, canvas.height/2);

  const tex = new THREE.CanvasTexture(canvas);
  const mat = new THREE.MeshBasicMaterial({ map:tex, transparent:true, opacity, side:THREE.DoubleSide });
  const geo = new THREE.PlaneGeometry(canvas.width*worldScale, canvas.height*worldScale);
  const mesh = new THREE.Mesh(geo, mat);
  switch(plane){
    case 'yz': mesh.rotation.y=Math.PI/2; mesh.rotation.z=Math.PI/2; break;
    case 'zx': mesh.rotation.x=Math.PI/2; mesh.rotation.y+=Math.PI; break;
  }
  if(direction) mesh.rotation.z += THREE.MathUtils.degToRad(direction);
  mesh.position.set(...(options.offset ?? [0,0,0]));
  mesh.userData.fontSize = fontSize;     // 可視制御用
  mesh.userData.worldScale = worldScale; // 可視制御用
  if(nodeId) mesh.userData.nodeId = nodeId;
  return mesh;
}

function updateLabelsVisibility(){
  const camPos = camera.position;
  for(const label of labelGroup.children){
    const dist = camPos.distanceTo(label.getWorldPosition(new THREE.Vector3()));
    const fs = (label.userData.fontSize ?? 32) * (label.userData.worldScale ?? 0.1);
    const apparent = fs / dist;
    label.visible = (apparent > 0.003); // しきい値は調整OK
  }
}

/* --- ピッキング（ノード/ラベル） --- */
const nodeById = new Map();
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
renderer.domElement.addEventListener('click', (event)=>{
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX-rect.left)/rect.width)*2 - 1;
  mouse.y = -((event.clientY-rect.top)/rect.height)*2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const objs = nodeGroup.children.concat(labelGroup.children);
  const hit = raycaster.intersectObjects(objs, true);
  if(hit.length){
    const mesh = hit[0].object;
    if(mesh.userData.nodeId){
      const node = nodeById.get(mesh.userData.nodeId).userData;
      showNode(node);
    }
  }
});

/* --- カメラ合わせ --- */
function fitCameraToScene(padding=1.2){
  controls.reset();
  const box = new THREE.Box3().setFromObject(scene);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);
  const fov = camera.fov * (Math.PI/180);
  let cameraZ = Math.abs(maxDim/2 / Math.tan(fov/2)) * padding;
  camera.position.set(center.x+cameraZ, center.y+cameraZ, center.z+cameraZ);
  controls.target.copy(center);
  controls.update();
}

/* --- シーン構築 --- */
function buildScene(data){
  nodeGroup.clear(); edgeGroup.clear(); labelGroup.clear(); auxiliaryGroup.clear(); nodeById.clear();

  const sphere = new THREE.SphereGeometry(0.05, 8, 8);

  for(const n of (data.nodes||[])){
    const mat = new THREE.MeshBasicMaterial({ color:0xaaaaaa, transparent:true, opacity:0.3 });
    const m = new THREE.Mesh(sphere, mat);
    m.position.set(...n.position);
    m.userData = n;
    nodeGroup.add(m);
    nodeById.set(n.id, m);
    if(n.label){
      const L = makeLabelPlane(n.label, n.labelAttr||{}, n.id);
      m.add(L);
    }
  }

  for(const e of (data.edges||[])){
    const a = nodeById.get(e.source), b = nodeById.get(e.target);
    if(!a || !b) continue;
    const geo = new THREE.BufferGeometry().setFromPoints([a.position, b.position]);
    const mat = new THREE.LineBasicMaterial({ color:e.color||0x9ec1ff, transparent:true, opacity:e.opacity??1.0 });
    edgeGroup.add(new THREE.Line(geo, mat));
    if(e.label){
      const mid = new THREE.Vector3().addVectors(a.position, b.position).multiplyScalar(0.5);
      const EL = makeLabelPlane(e.label, e.labelAttr||{});
      EL.position.copy(mid);
      labelGroup.add(EL);
    }
  }

  for(const aux of (data.auxiliary||[])){
    if(aux.type==='grid' && aux.grid){
      const g = aux.grid;
      if(g.shape==='rect'){
        const sizeU=g.sizeU??10, sizeV=g.sizeV??10, divU=g.divisionsU??10;
        const color=g.color??0x444444;
        const grid = new THREE.GridHelper(sizeU, divU, color, color);
        grid.scale.set(1, sizeV/sizeU, 1);
        grid.material.transparent = true; grid.material.opacity = g.opacity??0.3;
        if(g.plane==='yz') grid.rotation.z = Math.PI/2;
        if(g.plane==='zx') grid.rotation.x = Math.PI/2;
        if(g.position) grid.position.set(...g.position);
        if(aux.visible===false) grid.visible=false;
        auxiliaryGroup.add(grid);
      }
      if(g.shape==='polar'){
        const rings=g.rings??5, seg=g.segments??36;
        const radius=g.size??5;
        const mat = new THREE.LineBasicMaterial({ color:g.color??0x444444, transparent:true, opacity:g.opacity??0.3 });
        const thetaLen = g.mode==='half' ? Math.PI : g.mode==='quarter' ? Math.PI/2 : Math.PI*2;
        for(let r=1;r<=rings;r++){
          const pts=[];
          for(let i=0;i<=seg;i++){
            const th = (i/seg)*thetaLen;
            pts.push(new THREE.Vector3(Math.cos(th)*radius*r/rings, Math.sin(th)*radius*r/rings, 0));
          }
          const geom = new THREE.BufferGeometry().setFromPoints(pts);
          const loop = new THREE.LineLoop(geom, mat);
          if(g.plane==='yz') loop.rotation.y=Math.PI/2;
          if(g.plane==='zx') loop.rotation.x=Math.PI/2;
          if(g.position) loop.position.set(...g.position);
          if(aux.visible===false) loop.visible=false;
          auxiliaryGroup.add(loop);
        }
      }
    }
    if(aux.type==='axis'){
      const len = aux.length??5;
      const axes = new THREE.AxesHelper(len);
      if(aux.position) axes.position.set(...aux.position);
      if(aux.visible===false) axes.visible=false;
      auxiliaryGroup.add(axes);
    }
  }

  showMeta(data.meta, data);
  fitCameraToScene();
  renderer.render(scene, camera); // 読み込み直後に即反映
}

/* --- サイド情報表示 --- */
function showMeta(meta,data){
  const box=document.getElementById('meta'); box.innerHTML='';
  if(meta){ for(const [k,v] of Object.entries(meta)){ const d=document.createElement('div'); d.className='meta-item'; d.textContent=`${k}: ${v}`; box.appendChild(d);} }
}
function showNode(node){
  const box=document.getElementById('node'); box.innerHTML=''; if(!node) return;
  for(const [k,v] of Object.entries(node)){ const d=document.createElement('div'); d.className='node-item'; d.textContent=`${k}: ${v}`; box.appendChild(d); }
}

/* --- i18n(最低限) --- */
let dict={}; const ajv=new Ajv({allErrors:true,strict:false});
ajv.addFormat("uri",true); ajv.addFormat("uri-reference",true); ajv.addFormat("uri-template",true);
ajv.addFormat("json-pointer",true); ajv.addFormat("relative-json-pointer",true);
let validateModel=null, validateManifest=null;
async function loadSchemas(){
  try{
    const [modelSchema, manifestSchema] = await Promise.all([
      fetch('/digidiorama/digidiorama.schema.json').then(r=>r.ok?r.json():Promise.reject(new Error('model schema not found'))),
      fetch('/digidiorama/manifest.schema.json').then(r=>r.ok?r.json():Promise.reject(new Error('manifest schema not found')))
    ]);
    validateModel=ajv.compile(modelSchema); validateManifest=ajv.compile(manifestSchema);
  }catch(err){
    const fallback={type:'object',properties:{meta:{type:'object'},nodes:{type:'array'},edges:{type:'array'},auxiliary:{type:'array'}},required:['meta','nodes','edges']};
    validateModel=ajv.compile(fallback);
  }
}
function extraChecks(data){
  const msgs=[]; const ids=new Set();
  for(const n of (data.nodes||[])){ if(n&&typeof n.id==='string'){ if(ids.has(n.id)) msgs.push(`Duplicate node id: ${n.id}`); ids.add(n.id); } }
  for(const e of (data.edges||[])){ if(e&&typeof e.source==='string'&&!ids.has(e.source)) msgs.push(`Edge source not found: ${e.source}`); if(e&&typeof e.target==='string'&&!ids.has(e.target)) msgs.push(`Edge target not found: ${e.target}`); }
  return msgs;
}
function runValidation(data){
  const msgs=[]; if(typeof validateModel==='function'){ const ok=validateModel(data); if(!ok) msgs.push(...validateModel.errors.map(e=>`${e.instancePath||'/'} ${e.message}`)); }
  msgs.push(...extraChecks(data)); showErrors(msgs);
}
function showErrors(errs){ const box=document.getElementById('errors'); box.innerHTML=''; (errs||[]).forEach(e=>{ const d=document.createElement('div'); d.className='error-item'; d.textContent=e; box.appendChild(d); }); }

/* --- UI: 読み込み・パネル・レイヤ --- */
document.getElementById('btnLoad').onclick = async ()=>{
  const input=document.createElement('input'); input.type='file'; input.accept='.json';
  input.onchange = async (e)=>{
    const file=e.target.files[0]; if(!file) return;
    try{ const data=JSON.parse(await file.text()); runValidation(data); buildScene(data); }catch(err){ alert('JSONの読み込みに失敗しました: '+err.message); }
  };
  input.click();
};
document.getElementById('btnUrlLoad').onclick = async ()=>{
  const url=prompt('読み込みたい JSON の URL を入力してください:'); if(!url) return;
  try{ const res=await fetch(url); if(!res.ok) throw new Error('HTTP '+res.status); const data=await res.json(); runValidation(data); buildScene(data); }catch(err){ alert('URL読み込み失敗: '+err.message); }
};
document.getElementById('btnReset').onclick = ()=>{ fitCameraToScene(); renderer.render(scene, camera); };

const panel = document.getElementById('panel');
const fab   = document.getElementById('fab');
fab.onclick = ()=>{ panel.classList.toggle('open'); }; // 開閉のみ

const infoPanel = document.getElementById('infoPanel');
document.getElementById('toggleInfo').onclick = ()=>{ infoPanel.classList.toggle('active'); };

document.getElementById('btnLayers').onclick = ()=>{
  const dd = document.getElementById('layersDropdown');
  dd.style.display = dd.style.display === 'none' ? 'block' : 'none';
};
document.getElementById('toggle-nodes').onchange = (ev)=>{ nodeGroup.visible = ev.target.checked; renderer.render(scene,camera); };
document.getElementById('toggle-edges').onchange = (ev)=>{ edgeGroup.visible = ev.target.checked; renderer.render(scene,camera); };
document.getElementById('toggle-labels').onchange = (ev)=>{ labelGroup.visible = ev.target.checked; renderer.render(scene,camera); };
document.getElementById('toggle-aux').onchange   = (ev)=>{ auxiliaryGroup.visible = ev.target.checked; renderer.render(scene,camera); };

/* --- リサイズ対応（container基準） --- */
new ResizeObserver(()=>{
  const w=container.clientWidth, h=container.clientHeight;
  renderer.setSize(w,h,true); camera.aspect = w/h; camera.updateProjectionMatrix();
}).observe(container);

/* --- 起動処理 --- */
loadSchemas();
</script>
</body>
</html>
