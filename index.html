<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>digidiorama viewer/</title>

  <!-- 404対策: インラインSVGファビコン（ファイル不要） -->
  <link rel="icon"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' fill='%230b1020'/%3E%3Ctext x='50' y='62' font-size='64' text-anchor='middle' fill='%235aa9ff'%3EΔ%3C/text%3E%3C/svg%3E">

  <style>
    :root { --bg:#0b1020; --fg:#e6edf3; --accent:#5aa9ff; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui}
    #app{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr}
    header{display:flex;gap:.5rem;align-items:center;padding:.5rem .75rem;background:#0e142a;border-bottom:1px solid #1d2748}
    header h1{font-size:14px;font-weight:600;margin:0;letter-spacing:.3px}
    header .spacer{flex:1}
    header select,header button{appearance:none;border:1px solid #2a3969;background:#131a33;color:var(--fg);padding:.5rem 1rem;border-radius:.4rem;cursor:pointer;min-height:44px}
    header button:hover,header select:hover{border-color:#39529c;background:#1a2347}
    #main{display:grid;grid-template-columns:1fr 250px;overflow:hidden}
    #viewer{position:relative;overflow:hidden}
    #panel{background:#10172c;border-left:1px solid #1d2748;padding:.5rem;overflow-y:auto;transition:transform .3s ease}
    #panel h2{font-size:13px;margin:.5rem 0}
    #panel .meta-item,#panel .error-item,#panel .node-item{font-size:12px;margin-bottom:.25rem}
    .credit{position:absolute;right:.5rem;bottom:.5rem;font-size:11px;opacity:.7}
    canvas{display:block;width:100%;height:100%;}
    #tabs{display:none;margin-bottom:.5rem}
    #tabs button{flex:1;padding:.5rem;border:none;background:#2a3969;color:#fff;border-radius:.3rem;cursor:pointer}
    #tabs button.active{background:var(--accent)}
    .tab-pane{display:block}
    @media(max-width:600px){
      #main{grid-template-columns:1fr}
      #panel{position:absolute;z-index:10;width:100%;height:40%;bottom:0;left:0;border-left:none;border-top:1px solid #1d2748;transform:translateY(100%)}
      #panel.open{transform:translateY(0)}
      #fab{position:absolute;right:.75rem;bottom:.75rem;width:56px;height:56px;border-radius:50%;background:var(--accent);color:#fff;border:none;font-size:24px;cursor:pointer;z-index:20}
      #tabs{display:flex;gap:.5rem}
      #tab-content .tab-pane{display:none}
      #tab-content .tab-pane.active{display:block}
    }
    @media(min-width:601px){
      #panel{width:250px;right:0;top:0;height:100%;transform:translateX(0)}
      #panel.closed{transform:translateX(100%)}
      #fab{position:absolute;right:.75rem;bottom:.75rem;width:56px;height:56px;border-radius:50%;background:var(--accent);color:#fff;border:none;font-size:24px;cursor:pointer;z-index:20}
      #tabs{display:none}
      #tab-content .tab-pane{display:block}
    }
  </style>

  <!-- importmap は JSON のみ（JSは入れないこと！） -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "ajv": "https://esm.sh/ajv@8/dist/2020?bundle"
      }
    }
  </script>
</head>
<body>
  <div id="app">
    <header>
      <h1 data-i18n="title">デジジオラマ</h1>
      <div class="spacer"></div>

      <select id="fileSelect"></select>
      <select id="langSelect">
        <option value="ja">日本語</option>
        <option value="en">English</option>
      </select>

      <button id="btnReset" data-i18n="reset">Reset</button>
      <!-- 追加: Fit ボタン -->
      <button id="btnFit" title="Fit camera to scene">Fit</button>

      <div id="layersMenu" style="position:relative;">
        <button id="btnLayers" data-i18n="layers">Layers ▼</button>
        <div id="layersDropdown" style="display:none;position:absolute;right:0;top:100%;background:#131a33;border:1px solid #2a3969;padding:.5rem;border-radius:.4rem;">
          <label><input type="checkbox" id="toggle-nodes" checked> Nodes</label><br>
          <label><input type="checkbox" id="toggle-edges" checked> Edges</label><br>
          <label><input type="checkbox" id="toggle-labels" checked> Labels</label><br>
          <label><input type="checkbox" id="toggle-aux" checked> Auxiliary</label>
        </div>
      </div>
    </header>

    <div id="main">
      <div id="viewer"></div>
      <div id="panel" class="closed">
        <div id="tabs">
          <button data-tab="node" class="active">Node</button>
          <button data-tab="errors">Errors</button>
          <button data-tab="meta">Meta</button>
        </div>
        <div id="tab-content">
          <div id="node" class="tab-pane active"></div>
          <div id="errors" class="tab-pane"></div>
          <div id="meta" class="tab-pane">
            <!-- showMeta() が参照する counts プレースホルダ -->
            <div id="counts"></div>
          </div>
        </div>
      </div>
    </div>
    <button id="fab">≡</button>
  </div>
  <div class="credit">MIT © q2t-project / Content © respective authors</div>

  <!-- 以降は通常の module スクリプト -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import Ajv from 'ajv';

    const container = document.getElementById('viewer');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1020);

    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
    camera.up.set(0,0,1);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.update();

    // lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5,10,7);
    scene.add(dir);

    // groups
    const nodeGroup = new THREE.Group();
    const edgeGroup = new THREE.Group();
    const labelGroup = new THREE.Group();
    const auxiliaryGroup = new THREE.Group();
    scene.add(edgeGroup, nodeGroup, labelGroup, auxiliaryGroup);

    // label helper
    function makeLabelPlane(text, options={}, nodeId=null){
      const fontSize  = options.fontSize  ?? 32;
      const fontFamily= options.fontFamily?? 'Arial';
      const color     = options.color     ?? 'white';
      const opacity   = options.opacity   ?? 1.0;
      const background= options.background?? null;
      const plane     = options.plane     ?? 'zx';
      const direction = options.direction ?? 0;
      const worldScale= options.worldScale?? 0.1;

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = `${fontSize}px ${fontFamily}`;
      const metrics = ctx.measureText(text);
      canvas.width = metrics.width + 20;
      canvas.height = fontSize * 1.5;
      ctx.font = `${fontSize}px ${fontFamily}`;
      if(background){ ctx.fillStyle = background; ctx.fillRect(0,0,canvas.width,canvas.height); }
      ctx.fillStyle = color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, canvas.width/2, canvas.height/2);

      const texture = new THREE.CanvasTexture(canvas);
      const mat = new THREE.MeshBasicMaterial({ map:texture, transparent:true, opacity, side:THREE.DoubleSide });
      const geom = new THREE.PlaneGeometry(canvas.width*worldScale, canvas.height*worldScale);
      const mesh = new THREE.Mesh(geom, mat);

      switch(plane){
        case 'yz': mesh.rotation.y = Math.PI/2; mesh.rotation.z = Math.PI/2; break;
        case 'zx': mesh.rotation.x = Math.PI/2; mesh.rotation.y += Math.PI; break;
      }
      if(direction) mesh.rotation.z += THREE.MathUtils.degToRad(direction);
      if(options.offset) mesh.position.set(...options.offset);
      if(nodeId) mesh.userData.nodeId = nodeId;
      return mesh;
    }

    const nodeById = new Map();

    // pick node/label
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    renderer.domElement.addEventListener('click', e=>{
      const r = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - r.left) / r.width) * 2 - 1;
      mouse.y = -((e.clientY - r.top) / r.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(nodeGroup.children.concat(labelGroup.children), true);
      if(hits.length){
        const m = hits[0].object;
        if(m.userData.nodeId){
          const n = nodeById.get(m.userData.nodeId).userData;
          showNode(n);
        }
      }
    });

    // ★Fit: シーン全体にカメラを合わせる
    function fitCameraToScene(padding=1.2){
      const box = new THREE.Box3().setFromObject(scene);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x,size.y,size.z) || 1;
      const fov = camera.fov * (Math.PI/180);
      let dist = Math.abs(maxDim/2 / Math.tan(fov/2));
      dist *= padding;
      camera.position.set(center.x + dist, center.y + dist, center.z + dist);
      controls.target.copy(center);
      controls.update();
    }

    function buildScene(data){
      nodeGroup.clear(); edgeGroup.clear(); labelGroup.clear(); auxiliaryGroup.clear(); nodeById.clear();
      const sphere = new THREE.SphereGeometry(0.05, 8, 8);

      for(const n of (data.nodes||[])){
        const mat = new THREE.MeshBasicMaterial({ color:0xaaaaaa, transparent:true, opacity:0.3 });
        const m = new THREE.Mesh(sphere, mat); m.position.set(...n.position); m.userData = n;
        nodeGroup.add(m); nodeById.set(n.id, m);
        if(n.label){ m.add(makeLabelPlane(n.label, n.labelAttr||{}, n.id)); }
      }

      for(const e of (data.edges||[])){
        const a = nodeById.get(e.source), b = nodeById.get(e.target);
        if(!a || !b) continue;
        const geo = new THREE.BufferGeometry().setFromPoints([a.position, b.position]);
        const mat = new THREE.LineBasicMaterial({ color:e.color||0x9ec1ff, transparent:true, opacity:e.opacity||1.0 });
        edgeGroup.add(new THREE.Line(geo, mat));
        if(e.label){
          const mid = new THREE.Vector3().addVectors(a.position,b.position).multiplyScalar(0.5);
          const L = makeLabelPlane(e.label, e.labelAttr||{});
          L.position.copy(mid); labelGroup.add(L);
        }
      }

      for(const aux of (data.auxiliary||[])){
        if(aux.type==='grid' && aux.grid){
          const g = aux.grid;
          if(g.shape==='rect'){
            const size=g.size??10, div=g.divisions??10, color=g.color??0x444444;
            const grid=new THREE.GridHelper(size,div,color,color);
            grid.material.opacity=g.opacity??0.3; grid.material.transparent=true;
            if(g.plane==='yz') grid.rotation.z=Math.PI/2;
            if(g.plane==='zx') grid.rotation.x=Math.PI/2;
            if(g.position) grid.position.set(...g.position);
            if(aux.visible===false) grid.visible=false;
            auxiliaryGroup.add(grid);
          }
        }
        if(aux.type==='axis'){
          const len=aux.length??1, colors=aux.colors||['#f00','#0f0','#00f'];
          [[1,0,0],[0,1,0],[0,0,1]].forEach((d,i)=>{
            const geom=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(...d).multiplyScalar(len)]);
            const mat=new THREE.LineBasicMaterial({color:colors[i]});
            const line=new THREE.Line(geom,mat);
            if(aux.position) line.position.set(...aux.position);
            if(aux.visible===false) line.visible=false;
            auxiliaryGroup.add(line);
          });
        }
      }

      showMeta(data.meta, data);
      fitCameraToScene();
    }

    function showMeta(meta,data){
      const box=document.getElementById('meta');
      box.innerHTML='';
      if(meta){ for(const [k,v] of Object.entries(meta)){ const d=document.createElement('div'); d.className='meta-item'; d.textContent=`${k}: ${v}`; box.appendChild(d); } }
      const countsEl = document.getElementById('counts');
      if(countsEl){ countsEl.innerHTML = `<p>Nodes: ${(data.nodes||[]).length}</p><p>Edges: ${(data.edges||[]).length}</p>`; }
    }

    function showNode(node){
      const box=document.getElementById('node'); box.innerHTML='';
      if(!node) return;
      for(const [k,v] of Object.entries(node)){ const d=document.createElement('div'); d.className='node-item'; d.textContent=`${k}: ${v}`; box.appendChild(d); }
    }

    function showErrors(errs){
      const box=document.getElementById('errors'); box.innerHTML='';
      (errs||[]).forEach(e=>{ const d=document.createElement('div'); d.className='error-item'; d.textContent=e; box.appendChild(d); });
    }

    // i18n
    let dict = {};
    async function loadLocale(locale='ja'){
      const url = `./assets/i18n/${locale}.json?v=${Date.now()}`;
      try{
        const res = await fetch(url, {cache:'no-store'});
        if(!res.ok) throw new Error(`HTTP ${res.status}`);
        dict = await res.json();
      }catch(e){
        console.warn(`i18n ${locale} not found at ${url}`, e);
        dict = {};
      }
      applyI18n();
    }
    function applyI18n(){
      document.querySelectorAll('[data-i18n]').forEach(el=>{
        const k = el.dataset.i18n;
        if(k in dict) el.textContent = dict[k];
      });
    }

    // タブ / パネル
    document.querySelectorAll('#tabs button').forEach(btn=>{
      btn.onclick=()=>{
        const tab=btn.dataset.tab;
        document.querySelectorAll('#tab-content .tab-pane').forEach(p=>p.classList.toggle('active',p.id===tab));
        document.querySelectorAll('#tabs button').forEach(b=>b.classList.toggle('active',b===btn));
      };
    });
    if(window.innerWidth<=600){ document.querySelector('#node').classList.add('active'); }
    const panel=document.getElementById('panel');
    const fab=document.getElementById('fab');
    fab.onclick=()=>{ panel.classList.toggle('open'); panel.classList.toggle('closed'); };

    // Layers（保存なし：そのまま切り替えのみ）
    document.getElementById('btnLayers').onclick=()=>{
      const dd=document.getElementById('layersDropdown');
      dd.style.display = (dd.style.display==='none' ? 'block' : 'none');
    };
    document.getElementById('toggle-nodes').onchange = e=>{ nodeGroup.visible = e.target.checked; };
    document.getElementById('toggle-edges').onchange = e=>{ edgeGroup.visible = e.target.checked; };
    document.getElementById('toggle-labels').onchange= e=>{ labelGroup.visible = e.target.checked; };
    document.getElementById('toggle-aux').onchange   = e=>{ auxiliaryGroup.visible = e.target.checked; };

    // AJV スキーマ
    const ajv = new Ajv({ allErrors:true, strict:false, validateSchema:false });
    let validateModel = null, validateManifest = null;

    async function loadSchemas(){
      try{
        const [modelSchema,manifestSchema] = await Promise.all([
          fetch('./digidiorama.schema.json').then(r=> r.ok ? r.json() : Promise.reject(new Error('model schema not found'))),
          fetch('./manifest.schema.json').then(r=> r.ok ? r.json() : Promise.reject(new Error('manifest schema not found')))
        ]);
        validateModel   = ajv.compile(modelSchema);
        validateManifest= ajv.compile(manifestSchema);
      }catch(err){
        console.warn('Schema load failed, fallback to minimal schema', err);
        const fallback = {type:'object',properties:{meta:{type:'object'},nodes:{type:'array'},edges:{type:'array'},auxiliary:{type:'array'}},required:['meta','nodes','edges']};
        validateModel = ajv.compile(fallback);
      }
    }

    function extraChecks(data){
      const msgs=[], ids=new Set();
      for(const n of (data.nodes||[])){
        if(!n || typeof n.id!=='string') continue;
        if(ids.has(n.id)) msgs.push(`Duplicate node id: ${n.id}`);
        ids.add(n.id);
      }
      for(const e of (data.edges||[])){
        if(e && typeof e.source==='string' && !ids.has(e.source)) msgs.push(`Edge source not found: ${e.source}`);
        if(e && typeof e.target==='string' && !ids.has(e.target)) msgs.push(`Edge target not found: ${e.target}`);
      }
      return msgs;
    }

    function runValidation(data){
      const msgs=[];
      if(typeof validateModel==='function'){
        const ok = validateModel(data);
        if(!ok) msgs.push(...validateModel.errors.map(e=>`${e.instancePath||'/'} ${e.message}`));
      }
      msgs.push(...extraChecks(data));
      showErrors(msgs);
    }

    async function loadManifest(){ const res = await fetch('./assets/manifest.json'); return res.json(); }
    async function loadDigidiorama(path){ const res = await fetch(path); return res.json(); }

    // 初期ロード
    const select=document.getElementById('fileSelect');
    loadSchemas().then(()=>loadManifest()).then(list=>{
      select.innerHTML = '';
      let firstPath = null;

      if(Array.isArray(list)){
        list.forEach((item,idx)=>{
          const opt=document.createElement('option');
          opt.value=item.path; opt.textContent=item.title||item.path;
          select.appendChild(opt);
          if(idx===0) firstPath=item.path;
        });
      }else if(list.groups){
        list.groups.forEach(group=>{
          const og=document.createElement('optgroup'); og.label=group.title;
          (group.files||[]).forEach(item=>{
            const opt=document.createElement('option');
            opt.value=item.path; opt.textContent=item.title||item.path;
            og.appendChild(opt); if(!firstPath) firstPath=item.path;
          });
          select.appendChild(og);
        });
      }

      if(firstPath){
        select.value=firstPath;
        loadDigidiorama(firstPath).then(data=>{ runValidation(data); buildScene(data); });
      }
    });
    select.onchange = ()=>{ loadDigidiorama(select.value).then(data=>{ runValidation(data); buildScene(data); }); };

    loadLocale('ja');

    // 追加: Fit ボタンのバインド（ここなら importmap と無関係）
    document.getElementById('btnFit')?.addEventListener('click', ()=> fitCameraToScene());

    // レイアウト更新
    const ro = new ResizeObserver(()=>{
      const {clientWidth:w, clientHeight:h} = container;
      renderer.setSize(w,h,true);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    });
    ro.observe(container);

    (function animate(){ controls.update(); renderer.render(scene,camera); requestAnimationFrame(animate); })();
  </script>
</body>
</html>
