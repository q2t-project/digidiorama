<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>digidiorama viewer — P2</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; color: #ddd; }
    #ui { position: absolute; top: 10px; right: 10px; z-index: 10; }
    #ui button { margin-left: 5px; padding: 5px 10px; }
    #sidebar {
      position: absolute; top: 0; right: 0; width: 260px; height: 100%;
      background: rgba(0,0,0,0.8); color: #ddd; padding: 10px; overflow:auto;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <button onclick="loadSample()">Sample Diagram</button>
    <button onclick="toggleLang()">日本語</button>
    <button onclick="resetView()">Reset</button>
    <button onclick="toggleLayers()">Layers</button>
  </div>
  <div id="sidebar">
    <h3>メタ情報</h3>
    <div id="meta"></div>
    <h3>node</h3>
    <div id="node"></div>
    <h3>エラー</h3>
    <div id="errors"></div>
  </div>
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/controls/OrbitControls.js";

    let scene, camera, renderer, controls;
    let nodes = {};
    let edges = [];
    let layers = { grid: true, nodes: true, labels: true };
    let lang = "ja";

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(3,3,5);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);

      // grid
      const grid = new THREE.GridHelper(20,20);
      grid.name = "grid";
      scene.add(grid);

      window.addEventListener("resize", ()=>{
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene,camera);
    }

    function clearScene() {
      for (let key in nodes) scene.remove(nodes[key]);
      edges.forEach(e=>scene.remove(e));
      nodes = {}; edges = [];
    }

    function loadSample() {
      clearScene();
      fetch("assets/sample_mixed.json")
        .then(r=>r.json())
        .then(data=>{
          document.getElementById("meta").textContent = JSON.stringify(data.meta,null,2);
          data.nodes.forEach(n=>{
            // sphere node
            const geom = new THREE.SphereGeometry(n.size||0.1,16,16);
            const mat = new THREE.MeshBasicMaterial({color:n.color||"#44aaff"});
            const sphere = new THREE.Mesh(geom,mat);
            sphere.position.set(...n.position);
            sphere.userData = n;

            // === ラベルを Mesh にアタッチ ===
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            ctx.font = "20px Arial";
            ctx.fillStyle = "white";
            ctx.fillText(n.label||"", 2, 20);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent:true, depthTest:false });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(0.5,0.25,1);
            sprite.position.set(0,(n.size||0.1)+0.1,0); // ノードの上に
            sphere.add(sprite);

            nodes[n.id] = sphere;
            scene.add(sphere);
          });

          data.edges.forEach(e=>{
            const src = nodes[e.source], tgt = nodes[e.target];
            if(!src||!tgt) return;
            const points = [src.position, tgt.position];
            const geom = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({color:e.color||"#aaa", transparent:true, opacity:e.opacity||1.0});
            const line = new THREE.Line(geom,mat);
            edges.push(line);
            scene.add(line);
          });
        })
        .catch(err=>{
          document.getElementById("errors").textContent = err;
        });
    }

    function toggleLang(){ lang = (lang==="ja")?"en":"ja"; }
    function resetView(){ camera.position.set(3,3,5); controls.update(); }
    function toggleLayers(){
      layers.nodes=!layers.nodes;
      for (let k in nodes) nodes[k].visible = layers.nodes;
      edges.forEach(e=>e.visible=layers.nodes);
      const g = scene.getObjectByName("grid");
      if(g) g.visible = layers.grid;
    }
  </script>
</body>
</html>
